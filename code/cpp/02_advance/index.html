
<!doctype html>
<html lang="zh" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
        <meta name="author" content="fuji">
      
      
      
        <link rel="prev" href="../01_basic/">
      
      
        <link rel="next" href="../../../record/inv_fastoct/">
      
      <link rel="icon" href="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202305130239130.svg">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.19">
    
    
      
        <title>「CPP」网络课程笔记-02 - FUJI's Mind Palace</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.eebd395e.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ecc896b0.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noto+Sans+SC:300,300i,400,400i,700,700i%7CFira+Code:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Noto Sans SC";--md-code-font:"Fira Code"}</style>
      
    
    
      <link rel="stylesheet" href="../../../extra.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#c" class="md-skip">
          跳转至
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

<header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="页眉">
    <a href="../../.." title="FUJI&#39;s Mind Palace" class="md-header__button md-logo" aria-label="FUJI's Mind Palace" data-md-component="logo">
      
  <img src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202305130236896.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            FUJI's Mind Palace
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              「CPP」网络课程笔记-02
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_1">
            
              <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_2" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 7a5 5 0 0 1 5 5 5 5 0 0 1-5 5 5 5 0 0 1-5-5 5 5 0 0 1 5-5m0 2a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3m0-7 2.39 3.42C13.65 5.15 12.84 5 12 5c-.84 0-1.65.15-2.39.42L12 2M3.34 7l4.16-.35A7.2 7.2 0 0 0 5.94 8.5c-.44.74-.69 1.5-.83 2.29L3.34 7m.02 10 1.76-3.77a7.131 7.131 0 0 0 2.38 4.14L3.36 17M20.65 7l-1.77 3.79a7.023 7.023 0 0 0-2.38-4.15l4.15.36m-.01 10-4.14.36c.59-.51 1.12-1.14 1.54-1.86.42-.73.69-1.5.83-2.29L20.64 17M12 22l-2.41-3.44c.74.27 1.55.44 2.41.44.82 0 1.63-.17 2.37-.44L12 22Z"/></svg>
              </label>
            
          
            
            
            
            <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_2">
            
              <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_1" hidden>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m17.75 4.09-2.53 1.94.91 3.06-2.63-1.81-2.63 1.81.91-3.06-2.53-1.94L12.44 4l1.06-3 1.06 3 3.19.09m3.5 6.91-1.64 1.25.59 1.98-1.7-1.17-1.7 1.17.59-1.98L15.75 11l2.06-.05L18.5 9l.69 1.95 2.06.05m-2.28 4.95c.83-.08 1.72 1.1 1.19 1.85-.32.45-.66.87-1.08 1.27C15.17 23 8.84 23 4.94 19.07c-3.91-3.9-3.91-10.24 0-14.14.4-.4.82-.76 1.27-1.08.75-.53 1.93.36 1.85 1.19-.27 2.86.69 5.83 2.89 8.02a9.96 9.96 0 0 0 8.02 2.89m-1.64 2.02a12.08 12.08 0 0 1-7.8-3.47c-2.17-2.19-3.33-5-3.49-7.82-2.81 3.14-2.7 7.96.31 10.98 3.02 3.01 7.84 3.12 10.98.31Z"/></svg>
              </label>
            
          
        </form>
      
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="搜索" placeholder="搜索" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="查找">
        
        <button type="reset" class="md-search__icon md-icon" title="清空当前内容" aria-label="清空当前内容" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
        <div class="md-search__suggest" data-md-component="search-suggest"></div>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            正在初始化搜索引擎
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
            
<nav class="md-tabs" aria-label="标签" data-md-component="tabs">
  <div class="md-grid">
    <ul class="md-tabs__list">
      
        
  
  


  <li class="md-tabs__item">
    <a href="../../.." class="md-tabs__link">
      HOME
    </a>
  </li>

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../CS/basic/summary/" class="md-tabs__link">
        CS
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../ML/basic_paradigm/" class="md-tabs__link">
        ML
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../CG/basic/" class="md-tabs__link">
        CG
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../CV/3d_vision/" class="md-tabs__link">
        CV
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../algo/" class="md-tabs__link">
        ALGO
      </a>
    </li>
  

  

      
        
  
  
    
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../" class="md-tabs__link md-tabs__link--active">
        CODE
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../record/inv_fastoct/" class="md-tabs__link">
        RECORD
      </a>
    </li>
  

  

      
        
  
  


  
  
  
    

  
  
  
    <li class="md-tabs__item">
      <a href="../../../note/paper/" class="md-tabs__link">
        NOTE
      </a>
    </li>
  

  

      
    </ul>
  </div>
</nav>
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

  


<nav class="md-nav md-nav--primary md-nav--lifted" aria-label="导航栏" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="FUJI&#39;s Mind Palace" class="md-nav__button md-logo" aria-label="FUJI's Mind Palace" data-md-component="logo">
      
  <img src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202305130236896.svg" alt="logo">

    </a>
    FUJI's Mind Palace
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        HOME
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          CS
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          CS
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
      
      
        
          
            
          
        
          
            
          
        
          
            
          
        
          
            
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../CS/basic/summary/">计算机基础</a>
          
            <label for="__nav_2_1">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          计算机基础
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/basic/cs/" class="md-nav__link">
        计算机组成原理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/basic/os/" class="md-nav__link">
        操作系统
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/basic/cn/" class="md-nav__link">
        计算机网络
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/software/oo/" class="md-nav__link">
        面向对象
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/software/software/" class="md-nav__link">
        软件工程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/basic/summary/01_basic_summary/" class="md-nav__link">
        计算机基础总结
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
      
      
        
          
            
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../CS/others/">其他内容</a>
          
            <label for="__nav_2_2">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          其他内容
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/others/matlab/" class="md-nav__link">
        matlab课程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CS/others/mathematical_modeling/" class="md-nav__link">
        数学建模课程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          ML
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          ML
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
      
      
        
          
            
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../ML/basic_paradigm/">基本学习范式</a>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_1">
          <span class="md-nav__icon md-icon"></span>
          基本学习范式
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
      
      
        
          
            
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../ML/course_whiteboard/">白板推导课程</a>
          
            <label for="__nav_3_2">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2">
          <span class="md-nav__icon md-icon"></span>
          白板推导课程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../ML/course_whiteboard/00_hmm/" class="md-nav__link">
        隐马尔可夫链
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          CG
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          CG
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
      
      
        
          
            
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../CG/basic/">基础</a>
          
            <label for="__nav_4_1">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          基础
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CG/basic/matrix/" class="md-nav__link">
        矩阵变换
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" >
      
      
        
          
            
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../CG/rendering/">渲染</a>
          
            <label for="__nav_4_2">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_2">
          <span class="md-nav__icon md-icon"></span>
          渲染
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CG/rendering/basic/" class="md-nav__link">
        实时渲染基础
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CG/rendering/IBL/" class="md-nav__link">
        基于图像的照明
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" >
      
      
        
          
        
          
        
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          CV
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          CV
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_1" >
      
      
        
          
            
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../CV/3d_vision/">三维视觉</a>
          
            <label for="__nav_5_1">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_1">
          <span class="md-nav__icon md-icon"></span>
          三维视觉
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../CV/3d_vision/stereo/" class="md-nav__link">
        双目成像相关原理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
      
      
        
          
            
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../CV/image_processing/">图像处理</a>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2">
          <span class="md-nav__icon md-icon"></span>
          图像处理
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          ALGO
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          ALGO
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_1" >
      
      
        
          
            
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../algo/">你好算法</a>
          
            <label for="__nav_6_1">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6_1">
          <span class="md-nav__icon md-icon"></span>
          你好算法
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../algo/01_master_exam/" class="md-nav__link">
        机试笔记
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" checked>
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
          CODE
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          CODE
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
    
  
  
    
      
    
    <li class="md-nav__item md-nav__item--active md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_1" checked>
      
      
        
          
            
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../">C++</a>
          
            <label for="__nav_7_1">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_1_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_7_1">
          <span class="md-nav__icon md-icon"></span>
          C++
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../01_basic/" class="md-nav__link">
        网课笔记01
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          网课笔记02
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        网课笔记02
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1 模板
  </a>
  
    <nav class="md-nav" aria-label="1 模板">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 模板的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    1.2 函数模板
  </a>
  
    <nav class="md-nav" aria-label="1.2 函数模板">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#121" class="md-nav__link">
    1.2.1 函数模板语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#122-t" class="md-nav__link">
    1.2.2 函数模板注意事项 注意事项： * 自动类型推导，必须推导出 一致的数据类型 T 才可以使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#123" class="md-nav__link">
    1.2.3 函数模板案例 案例描述： * 利用函数模板封装一个排序的函数，可以对 不同数据类型数组 进行排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#124" class="md-nav__link">
    1.2.4 普通函数与函数模板的区别 普通函数与函数模板区别： * 普通函数调用时可以发生自动类型转换（隐式类型转换）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#125-1" class="md-nav__link">
    1.2.5 普通函数与函数模板的调用规则 调用规则如下： 1. 如果函数模板和普通函数都可以实现，优先调用普通函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#126-c" class="md-nav__link">
    1.2.6 模板的局限性 局限性： * 模板的通用性并不是万能的 例如： ```C++
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#136" class="md-nav__link">
    1.3.6 类模板成员函数类外实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
          RECORD
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          RECORD
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_1" >
      
      
        
          
            
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../record/inv_fastoct/">基于稀疏体素八叉树的室内场景神经逆渲染研究</a>
          
            <label for="__nav_8_1">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8_1">
          <span class="md-nav__icon md-icon"></span>
          基于稀疏体素八叉树的室内场景神经逆渲染研究
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/00_code_record/" class="md-nav__link">
        编程记录
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/01_RTE.md" class="md-nav__link">
        体渲染
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/01_vol_renderer.md" class="md-nav__link">
        NeRF体渲染
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/02_diff_vol_renderer.md" class="md-nav__link">
        可微体渲染
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/02_diff_vol_renderer_exper.md" class="md-nav__link">
        可微体渲染的实现
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/01_format_trans/" class="md-nav__link">
        坐标系定义0
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/01_ft01_i2p/" class="md-nav__link">
        坐标系定义1
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../record/inv_fastoct/01_ft02_p2v/" class="md-nav__link">
        坐标系定义2
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9" >
      
      
        
          
        
      
      
        <label class="md-nav__link" for="__nav_9" id="__nav_9_label" tabindex="0">
          NOTE
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_9_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_9">
          <span class="md-nav__icon md-icon"></span>
          NOTE
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
      
    
    <li class="md-nav__item md-nav__item--section md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_9_1" >
      
      
        
          
            
          
        
          
        
      
      
        
        
        <div class="md-nav__link md-nav__link--index ">
          <a href="../../../note/paper/">论文笔记</a>
          
            <label for="__nav_9_1">
              <span class="md-nav__icon md-icon"></span>
            </label>
          
        </div>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_9_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_9_1">
          <span class="md-nav__icon md-icon"></span>
          论文笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../../note/paper/SIGGRAPH2022_dual_ocnn/" class="md-nav__link">
        (2022 SIGGRAPH) dual ocnn
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="目录">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      目录
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#1" class="md-nav__link">
    1 模板
  </a>
  
    <nav class="md-nav" aria-label="1 模板">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#11" class="md-nav__link">
    1.1 模板的概念
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#12" class="md-nav__link">
    1.2 函数模板
  </a>
  
    <nav class="md-nav" aria-label="1.2 函数模板">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#121" class="md-nav__link">
    1.2.1 函数模板语法
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#122-t" class="md-nav__link">
    1.2.2 函数模板注意事项 注意事项： * 自动类型推导，必须推导出 一致的数据类型 T 才可以使用
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#123" class="md-nav__link">
    1.2.3 函数模板案例 案例描述： * 利用函数模板封装一个排序的函数，可以对 不同数据类型数组 进行排序
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#124" class="md-nav__link">
    1.2.4 普通函数与函数模板的区别 普通函数与函数模板区别： * 普通函数调用时可以发生自动类型转换（隐式类型转换）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#125-1" class="md-nav__link">
    1.2.5 普通函数与函数模板的调用规则 调用规则如下： 1. 如果函数模板和普通函数都可以实现，优先调用普通函数
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#126-c" class="md-nav__link">
    1.2.6 模板的局限性 局限性： * 模板的通用性并不是万能的 例如： ```C++
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#136" class="md-nav__link">
    1.3.6 类模板成员函数类外实现
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="c">C++提高编程<a class="headerlink" href="#c" title="Permanent link">&para;</a></h1>
<ul>
<li>本阶段主要针对C++ <strong>泛型编程</strong> 和 <strong>STL</strong> 技术做详细讲解，探讨C++更深层的使用。</li>
</ul>
<h2 id="1">1 模板<a class="headerlink" href="#1" title="Permanent link">&para;</a></h2>
<h3 id="11">1.1 模板的概念<a class="headerlink" href="#11" title="Permanent link">&para;</a></h3>
<p>模板就是建立 <strong>通用的模具</strong> ，大大 <strong>提高复用性</strong> 。</p>
<p>模板的特点：</p>
<ul>
<li>模板不可以直接使用，它只是一个框架</li>
<li>模板的通用并不是万能的</li>
</ul>
<p>例如生活中的模板：</p>
<table>
<thead>
<tr>
<th align="center"><img alt="1547105026929" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131216610.png" /></th>
<th align="center"><img alt="1547103297864" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131216927.png" /></th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">一寸照片模板</td>
<td align="center">PPT模板</td>
</tr>
</tbody>
</table>
<h3 id="12">1.2 函数模板<a class="headerlink" href="#12" title="Permanent link">&para;</a></h3>
<ul>
<li>
<p>除了面向对象，C++另一种编程思想称为 <strong>泛型编程</strong> ，主要利用的技术就是 <strong>模板</strong> 。</p>
</li>
<li>
<p>C++提供两种模板机制: <strong>函数模板</strong> 和 <strong>类模板</strong> 。</p>
</li>
</ul>
<h4 id="121">1.2.1 函数模板语法<a class="headerlink" href="#121" title="Permanent link">&para;</a></h4>
<p>函数模板 <strong>作用：</strong> - 建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个 <strong>虚拟的类型</strong> 来代表。 <strong>语法：</strong> <code>C++
template&lt;typename T&gt;
函数声明或定义</code> <strong>解释：</strong> - <code>template</code>  ---  声明创建模板</p>
<ul>
<li>
<p><code>typename</code>  --- 表面其后面的符号是一种数据类型，可以用class代替</p>
</li>
<li>
<p><code>T</code>    ---   通用的数据类型，名称可以替换，通常为大写字母 <strong>示例：</strong> ```C++
//交换整型函数
void swapInt(int&amp; a, int&amp; b) {
    int temp = a;
    a = b;
    b = temp;
}</p>
</li>
</ul>
<p>//交换浮点型函数
void swapDouble(double&amp; a, double&amp; b) {
    double temp = a;
    a = b;
    b = temp;
}</p>
<p>//利用模板提供通用的交换函数
template<typename T>
void mySwap(T&amp; a, T&amp; b)
{
    T temp = a;
    a = b;
    b = temp;
}</p>
<p>void test01()
{
    int a = 10;
    int b = 20;</p>
<div class="highlight"><pre><span></span><code>//swapInt(a, b);

//利用模板实现交换
//1、自动类型推导
mySwap(a, b);

//2、显示指定类型
mySwap&lt;int&gt;(a, b);

cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; endl;
cout &lt;&lt; &quot;b = &quot; &lt;&lt; b &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> * 函数模板利用关键字 template
* 使用函数模板有两种方式：自动类型推导、显示指定类型
* 模板的目的是为了提高复用性，将类型参数化</p>
<h4 id="122-t">1.2.2 函数模板注意事项 <strong>注意事项：</strong> * 自动类型推导，必须推导出 <strong>一致的数据类型 <code>T</code></strong> 才可以使用<a class="headerlink" href="#122-t" title="Permanent link">&para;</a></h4>
<ul>
<li>模板必须要确定出T的数据类型，才可以使用 <strong>示例：</strong> ```C++
//利用模板提供通用的交换函数
template<class T>
void mySwap(T&amp; a, T&amp; b)
{
    T temp = a;
    a = b;
    b = temp;
}</li>
</ul>
<p>// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用
void test01()
{
    int a = 10;
    int b = 20;
    char c = 'c';</p>
<div class="highlight"><pre><span></span><code>mySwap(a, b); // 正确，可以推导出一致的T
//mySwap(a, c); // 错误，推导不出一致的T类型
</code></pre></div>
<p>}</p>
<p>// 2、模板必须要确定出T的数据类型，才可以使用
template<class T>
void func()
{
    cout &lt;&lt; "func 调用" &lt;&lt; endl;
}</p>
<p>void test02()
{
    //func(); //错误，模板不能独立使用，必须确定出T的类型
    func<int>(); //利用显示指定类型的方式，给T一个类型，才可以使用该模板
}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();
test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> * 使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</p>
<h4 id="123">1.2.3 函数模板案例 <strong>案例描述：</strong> * 利用函数模板封装一个排序的函数，可以对 <strong>不同数据类型数组</strong> 进行排序<a class="headerlink" href="#123" title="Permanent link">&para;</a></h4>
<ul>
<li>排序规则从大到小，排序算法为 <strong>选择排序</strong> * 分别利用 <strong>char数组</strong> 和 <strong>int数组</strong> 进行测试 <strong>示例：</strong> ```C++
//交换的函数模板
template<typename T>
void mySwap(T &amp;a, T&amp;b)
{
    T temp = a;
    a = b;
    b = temp;
}</li>
</ul>
<p>template<class T> // 也可以替换成typename
//利用选择排序，进行对数组从大到小的排序
void mySort(T arr[], int len)
{
    for (int i = 0; i &lt; len; i++)
    {
        int max = i; //最大数的下标
        for (int j = i + 1; j &lt; len; j++)
        {
            if (arr[max] &lt; arr[j])
            {
                max = j;
            }
        }
        if (max != i) //如果最大数的下标不是i，交换两者
        {
            mySwap(arr[max], arr[i]);
        }
    }
}
template<typename T>
void printArray(T arr[], int len) {</p>
<div class="highlight"><pre><span></span><code>for (int i = 0; i &lt; len; i++) {
    cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}
void test01()
{
    //测试char数组
    char charArr[] = "bdcfeagh";
    int num = sizeof(charArr) / sizeof(char);
    mySort(charArr, num);
    printArray(charArr, num);
}</p>
<p>void test02()
{
    //测试int数组
    int intArr[] = { 7, 5, 8, 1, 3, 9, 2, 4, 6 };
    int num = sizeof(intArr) / sizeof(int);
    mySort(intArr, num);
    printArray(intArr, num);
}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();
test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> 模板可以提高代码复用，需要熟练掌握</p>
<h4 id="124">1.2.4 普通函数与函数模板的区别 <strong>普通函数与函数模板区别：</strong> * 普通函数调用时可以发生自动类型转换（隐式类型转换）<a class="headerlink" href="#124" title="Permanent link">&para;</a></h4>
<ul>
<li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li>
<li>如果利用显示指定类型的方式，可以发生隐式类型转换 <strong>示例：</strong> ```C++
//普通函数
int myAdd01(int a, int b)
{
    return a + b;
}</li>
</ul>
<p>//函数模板
template<class T>
T myAdd02(T a, T b)<br />
{
    return a + b;
}</p>
<p>//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换
void test01()
{
    int a = 10;
    int b = 20;
    char c = 'c';</p>
<div class="highlight"><pre><span></span><code>cout &lt;&lt; myAdd01(a, c) &lt;&lt; endl; //正确，将char类型的&#39;c&#39;隐式转换为int类型  &#39;c&#39; 对应 ASCII码 99

//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换

myAdd02&lt;int&gt;(a, c); //正确，如果用显示指定类型，可以发生隐式类型转换
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T
</p>
<h4 id="125-1">1.2.5 普通函数与函数模板的调用规则 <strong>调用规则如下：</strong> 1. 如果函数模板和普通函数都可以实现，优先调用普通函数<a class="headerlink" href="#125-1" title="Permanent link">&para;</a></h4>
<ol>
<li>可以通过空模板参数列表来强制调用函数模板</li>
<li>函数模板也可以发生重载</li>
<li>如果函数模板可以产生更好的匹配,优先调用函数模板 <strong>示例：</strong> <code>C++
//普通函数与函数模板调用规则
void myPrint(int a, int b)
{
    cout &lt;&lt; "调用的普通函数" &lt;&lt; endl;
}

template&lt;typename T&gt;
void myPrint(T a, T b) 
{ 
    cout &lt;&lt; "调用的模板" &lt;&lt; endl;
}

template&lt;typename T&gt;
void myPrint(T a, T b, T c) 
{ 
    cout &lt;&lt; "调用重载的模板" &lt;&lt; endl; 
}

void test01()
{
    //1、如果函数模板和普通函数都可以实现，优先调用普通函数
    // 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到
    int a = 10;
    int b = 20;
    myPrint(a, b); //调用普通函数

    //2、可以通过空模板参数列表来强制调用函数模板
    myPrint&lt;&gt;(a, b); //调用函数模板

    //3、函数模板也可以发生重载
    int c = 30;
    myPrint(a, b, c); //调用重载的函数模板

    //4、 如果函数模板可以产生更好的匹配,优先调用函数模板
    char c1 = 'a';
    char c2 = 'b';
    myPrint(c1, c2); //调用函数模板
}

int main() {

    test01();

    system("pause");

    return 0;
}</code> <strong>总结：</strong> 既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性。
</li>
</ol>
<h4 id="126-c">1.2.6 模板的局限性 <strong>局限性：</strong> * 模板的通用性并不是万能的 <strong>例如：</strong> ```C++<a class="headerlink" href="#126-c" title="Permanent link">&para;</a></h4>
<p>template<class T>
void f(T a, T b)
{ 
    a = b;
}
```</p>
<p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了。 <strong>再例如：</strong> ```C++
template<class T>
void f(T a, T b)
{ 
    if(a &gt; b) { ... }
}
<div class="highlight"><pre><span></span><code><a id="__codelineno-1-1" name="__codelineno-1-1" href="#__codelineno-1-1"></a>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行。
<a id="__codelineno-1-2" name="__codelineno-1-2" href="#__codelineno-1-2"></a>
<a id="__codelineno-1-3" name="__codelineno-1-3" href="#__codelineno-1-3"></a>因此C++为了解决这种问题，f提供模板的重载，可以为这些 **特定的类型** 提供 **具体化的模板** 。
<a id="__codelineno-1-4" name="__codelineno-1-4" href="#__codelineno-1-4"></a>
<a id="__codelineno-1-5" name="__codelineno-1-5" href="#__codelineno-1-5"></a>```c++
<a id="__codelineno-1-6" name="__codelineno-1-6" href="#__codelineno-1-6"></a>template&lt;&gt; void f(Person &amp;a, Person &amp;b)
<a id="__codelineno-1-7" name="__codelineno-1-7" href="#__codelineno-1-7"></a>{
<a id="__codelineno-1-8" name="__codelineno-1-8" href="#__codelineno-1-8"></a>    ...
<a id="__codelineno-1-9" name="__codelineno-1-9" href="#__codelineno-1-9"></a>}
<a id="__codelineno-1-10" name="__codelineno-1-10" href="#__codelineno-1-10"></a>``` **示例：** ```C++
<a id="__codelineno-1-11" name="__codelineno-1-11" href="#__codelineno-1-11"></a>#include&lt;iostream&gt;
<a id="__codelineno-1-12" name="__codelineno-1-12" href="#__codelineno-1-12"></a>using namespace std;
<a id="__codelineno-1-13" name="__codelineno-1-13" href="#__codelineno-1-13"></a>
<a id="__codelineno-1-14" name="__codelineno-1-14" href="#__codelineno-1-14"></a>#include &lt;string&gt;
<a id="__codelineno-1-15" name="__codelineno-1-15" href="#__codelineno-1-15"></a>
<a id="__codelineno-1-16" name="__codelineno-1-16" href="#__codelineno-1-16"></a>class Person
<a id="__codelineno-1-17" name="__codelineno-1-17" href="#__codelineno-1-17"></a>{
<a id="__codelineno-1-18" name="__codelineno-1-18" href="#__codelineno-1-18"></a>public:
<a id="__codelineno-1-19" name="__codelineno-1-19" href="#__codelineno-1-19"></a>    Person(string name, int age)
<a id="__codelineno-1-20" name="__codelineno-1-20" href="#__codelineno-1-20"></a>    {
<a id="__codelineno-1-21" name="__codelineno-1-21" href="#__codelineno-1-21"></a>        this-&gt;m_Name = name;
<a id="__codelineno-1-22" name="__codelineno-1-22" href="#__codelineno-1-22"></a>        this-&gt;m_Age = age;
<a id="__codelineno-1-23" name="__codelineno-1-23" href="#__codelineno-1-23"></a>    }
<a id="__codelineno-1-24" name="__codelineno-1-24" href="#__codelineno-1-24"></a>    string m_Name;
<a id="__codelineno-1-25" name="__codelineno-1-25" href="#__codelineno-1-25"></a>    int m_Age;
<a id="__codelineno-1-26" name="__codelineno-1-26" href="#__codelineno-1-26"></a>};
<a id="__codelineno-1-27" name="__codelineno-1-27" href="#__codelineno-1-27"></a>
<a id="__codelineno-1-28" name="__codelineno-1-28" href="#__codelineno-1-28"></a>//普通函数模板
<a id="__codelineno-1-29" name="__codelineno-1-29" href="#__codelineno-1-29"></a>template&lt;class T&gt;
<a id="__codelineno-1-30" name="__codelineno-1-30" href="#__codelineno-1-30"></a>bool myCompare(T&amp; a, T&amp; b)
<a id="__codelineno-1-31" name="__codelineno-1-31" href="#__codelineno-1-31"></a>{
<a id="__codelineno-1-32" name="__codelineno-1-32" href="#__codelineno-1-32"></a>    if (a == b)
<a id="__codelineno-1-33" name="__codelineno-1-33" href="#__codelineno-1-33"></a>    {
<a id="__codelineno-1-34" name="__codelineno-1-34" href="#__codelineno-1-34"></a>        return true;
<a id="__codelineno-1-35" name="__codelineno-1-35" href="#__codelineno-1-35"></a>    }
<a id="__codelineno-1-36" name="__codelineno-1-36" href="#__codelineno-1-36"></a>    else
<a id="__codelineno-1-37" name="__codelineno-1-37" href="#__codelineno-1-37"></a>    {
<a id="__codelineno-1-38" name="__codelineno-1-38" href="#__codelineno-1-38"></a>        return false;
<a id="__codelineno-1-39" name="__codelineno-1-39" href="#__codelineno-1-39"></a>    }
<a id="__codelineno-1-40" name="__codelineno-1-40" href="#__codelineno-1-40"></a>}
<a id="__codelineno-1-41" name="__codelineno-1-41" href="#__codelineno-1-41"></a>
<a id="__codelineno-1-42" name="__codelineno-1-42" href="#__codelineno-1-42"></a>
<a id="__codelineno-1-43" name="__codelineno-1-43" href="#__codelineno-1-43"></a>//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型
<a id="__codelineno-1-44" name="__codelineno-1-44" href="#__codelineno-1-44"></a>//具体化优先于常规模板
<a id="__codelineno-1-45" name="__codelineno-1-45" href="#__codelineno-1-45"></a>template&lt;&gt; bool myCompare(Person &amp;p1, Person &amp;p2)
<a id="__codelineno-1-46" name="__codelineno-1-46" href="#__codelineno-1-46"></a>{
<a id="__codelineno-1-47" name="__codelineno-1-47" href="#__codelineno-1-47"></a>    if ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)
<a id="__codelineno-1-48" name="__codelineno-1-48" href="#__codelineno-1-48"></a>    {
<a id="__codelineno-1-49" name="__codelineno-1-49" href="#__codelineno-1-49"></a>        return true;
<a id="__codelineno-1-50" name="__codelineno-1-50" href="#__codelineno-1-50"></a>    }
<a id="__codelineno-1-51" name="__codelineno-1-51" href="#__codelineno-1-51"></a>    else
<a id="__codelineno-1-52" name="__codelineno-1-52" href="#__codelineno-1-52"></a>    {
<a id="__codelineno-1-53" name="__codelineno-1-53" href="#__codelineno-1-53"></a>        return false;
<a id="__codelineno-1-54" name="__codelineno-1-54" href="#__codelineno-1-54"></a>    }
<a id="__codelineno-1-55" name="__codelineno-1-55" href="#__codelineno-1-55"></a>}
<a id="__codelineno-1-56" name="__codelineno-1-56" href="#__codelineno-1-56"></a>
<a id="__codelineno-1-57" name="__codelineno-1-57" href="#__codelineno-1-57"></a>void test01()
<a id="__codelineno-1-58" name="__codelineno-1-58" href="#__codelineno-1-58"></a>{
<a id="__codelineno-1-59" name="__codelineno-1-59" href="#__codelineno-1-59"></a>    int a = 10;
<a id="__codelineno-1-60" name="__codelineno-1-60" href="#__codelineno-1-60"></a>    int b = 20;
<a id="__codelineno-1-61" name="__codelineno-1-61" href="#__codelineno-1-61"></a>    //内置数据类型可以直接使用通用的函数模板
<a id="__codelineno-1-62" name="__codelineno-1-62" href="#__codelineno-1-62"></a>    bool ret = myCompare(a, b);
<a id="__codelineno-1-63" name="__codelineno-1-63" href="#__codelineno-1-63"></a>    if (ret)
<a id="__codelineno-1-64" name="__codelineno-1-64" href="#__codelineno-1-64"></a>    {
<a id="__codelineno-1-65" name="__codelineno-1-65" href="#__codelineno-1-65"></a>        cout &lt;&lt; &quot;a == b &quot; &lt;&lt; endl;
<a id="__codelineno-1-66" name="__codelineno-1-66" href="#__codelineno-1-66"></a>    }
<a id="__codelineno-1-67" name="__codelineno-1-67" href="#__codelineno-1-67"></a>    else
<a id="__codelineno-1-68" name="__codelineno-1-68" href="#__codelineno-1-68"></a>    {
<a id="__codelineno-1-69" name="__codelineno-1-69" href="#__codelineno-1-69"></a>        cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl;
<a id="__codelineno-1-70" name="__codelineno-1-70" href="#__codelineno-1-70"></a>    }
<a id="__codelineno-1-71" name="__codelineno-1-71" href="#__codelineno-1-71"></a>}
<a id="__codelineno-1-72" name="__codelineno-1-72" href="#__codelineno-1-72"></a>
<a id="__codelineno-1-73" name="__codelineno-1-73" href="#__codelineno-1-73"></a>void test02()
<a id="__codelineno-1-74" name="__codelineno-1-74" href="#__codelineno-1-74"></a>{
<a id="__codelineno-1-75" name="__codelineno-1-75" href="#__codelineno-1-75"></a>    Person p1(&quot;Tom&quot;, 10);
<a id="__codelineno-1-76" name="__codelineno-1-76" href="#__codelineno-1-76"></a>    Person p2(&quot;Tom&quot;, 10);
<a id="__codelineno-1-77" name="__codelineno-1-77" href="#__codelineno-1-77"></a>    //自定义数据类型，不会调用普通的函数模板
<a id="__codelineno-1-78" name="__codelineno-1-78" href="#__codelineno-1-78"></a>    //可以创建具体化的Person数据类型的模板，用于特殊处理这个类型
<a id="__codelineno-1-79" name="__codelineno-1-79" href="#__codelineno-1-79"></a>    bool ret = myCompare(p1, p2);
<a id="__codelineno-1-80" name="__codelineno-1-80" href="#__codelineno-1-80"></a>    if (ret)
<a id="__codelineno-1-81" name="__codelineno-1-81" href="#__codelineno-1-81"></a>    {
<a id="__codelineno-1-82" name="__codelineno-1-82" href="#__codelineno-1-82"></a>        cout &lt;&lt; &quot;p1 == p2 &quot; &lt;&lt; endl;
<a id="__codelineno-1-83" name="__codelineno-1-83" href="#__codelineno-1-83"></a>    }
<a id="__codelineno-1-84" name="__codelineno-1-84" href="#__codelineno-1-84"></a>    else
<a id="__codelineno-1-85" name="__codelineno-1-85" href="#__codelineno-1-85"></a>    {
<a id="__codelineno-1-86" name="__codelineno-1-86" href="#__codelineno-1-86"></a>        cout &lt;&lt; &quot;p1 != p2 &quot; &lt;&lt; endl;
<a id="__codelineno-1-87" name="__codelineno-1-87" href="#__codelineno-1-87"></a>    }
<a id="__codelineno-1-88" name="__codelineno-1-88" href="#__codelineno-1-88"></a>}
<a id="__codelineno-1-89" name="__codelineno-1-89" href="#__codelineno-1-89"></a>
<a id="__codelineno-1-90" name="__codelineno-1-90" href="#__codelineno-1-90"></a>int main() {
<a id="__codelineno-1-91" name="__codelineno-1-91" href="#__codelineno-1-91"></a>
<a id="__codelineno-1-92" name="__codelineno-1-92" href="#__codelineno-1-92"></a>    test01();
<a id="__codelineno-1-93" name="__codelineno-1-93" href="#__codelineno-1-93"></a>
<a id="__codelineno-1-94" name="__codelineno-1-94" href="#__codelineno-1-94"></a>    test02();
<a id="__codelineno-1-95" name="__codelineno-1-95" href="#__codelineno-1-95"></a>
<a id="__codelineno-1-96" name="__codelineno-1-96" href="#__codelineno-1-96"></a>    system(&quot;pause&quot;);
<a id="__codelineno-1-97" name="__codelineno-1-97" href="#__codelineno-1-97"></a>
<a id="__codelineno-1-98" name="__codelineno-1-98" href="#__codelineno-1-98"></a>    return 0;
<a id="__codelineno-1-99" name="__codelineno-1-99" href="#__codelineno-1-99"></a>}
<a id="__codelineno-1-100" name="__codelineno-1-100" href="#__codelineno-1-100"></a>``` **总结：** * 利用具体化的模板，可以解决自定义类型的通用化
<a id="__codelineno-1-101" name="__codelineno-1-101" href="#__codelineno-1-101"></a>* 学习模板并不是为了写模板，而是在STL能够运用系统提供的模板
<a id="__codelineno-1-102" name="__codelineno-1-102" href="#__codelineno-1-102"></a>
<a id="__codelineno-1-103" name="__codelineno-1-103" href="#__codelineno-1-103"></a>### 1.3 类模板
<a id="__codelineno-1-104" name="__codelineno-1-104" href="#__codelineno-1-104"></a>
<a id="__codelineno-1-105" name="__codelineno-1-105" href="#__codelineno-1-105"></a>#### 1.3.1 类模板语法
<a id="__codelineno-1-106" name="__codelineno-1-106" href="#__codelineno-1-106"></a>
<a id="__codelineno-1-107" name="__codelineno-1-107" href="#__codelineno-1-107"></a>类模板 **作用** ：
<a id="__codelineno-1-108" name="__codelineno-1-108" href="#__codelineno-1-108"></a>
<a id="__codelineno-1-109" name="__codelineno-1-109" href="#__codelineno-1-109"></a>* 建立一个通用类，类中的成员 数据类型可以不具体制定，用一个 **虚拟的类型** 来代表。 **语法：** ```c++
<a id="__codelineno-1-110" name="__codelineno-1-110" href="#__codelineno-1-110"></a>template&lt;typename T&gt;
<a id="__codelineno-1-111" name="__codelineno-1-111" href="#__codelineno-1-111"></a>类
<a id="__codelineno-1-112" name="__codelineno-1-112" href="#__codelineno-1-112"></a>``` **解释：** - `template`  ---  声明创建模板
<a id="__codelineno-1-113" name="__codelineno-1-113" href="#__codelineno-1-113"></a>
<a id="__codelineno-1-114" name="__codelineno-1-114" href="#__codelineno-1-114"></a>- `typename`  --- 表面其后面的符号是一种数据类型，可以用class代替
<a id="__codelineno-1-115" name="__codelineno-1-115" href="#__codelineno-1-115"></a>
<a id="__codelineno-1-116" name="__codelineno-1-116" href="#__codelineno-1-116"></a>- `T`    ---   通用的数据类型，名称可以替换，通常为大写字母 **示例：** ```C++
<a id="__codelineno-1-117" name="__codelineno-1-117" href="#__codelineno-1-117"></a>#include &lt;string&gt;
<a id="__codelineno-1-118" name="__codelineno-1-118" href="#__codelineno-1-118"></a>//类模板
<a id="__codelineno-1-119" name="__codelineno-1-119" href="#__codelineno-1-119"></a>template&lt;class NameType, class AgeType&gt; 
<a id="__codelineno-1-120" name="__codelineno-1-120" href="#__codelineno-1-120"></a>class Person
<a id="__codelineno-1-121" name="__codelineno-1-121" href="#__codelineno-1-121"></a>{
<a id="__codelineno-1-122" name="__codelineno-1-122" href="#__codelineno-1-122"></a>public:
<a id="__codelineno-1-123" name="__codelineno-1-123" href="#__codelineno-1-123"></a>    Person(NameType name, AgeType age)
<a id="__codelineno-1-124" name="__codelineno-1-124" href="#__codelineno-1-124"></a>    {
<a id="__codelineno-1-125" name="__codelineno-1-125" href="#__codelineno-1-125"></a>        this-&gt;mName = name;
<a id="__codelineno-1-126" name="__codelineno-1-126" href="#__codelineno-1-126"></a>        this-&gt;mAge = age;
<a id="__codelineno-1-127" name="__codelineno-1-127" href="#__codelineno-1-127"></a>    }
<a id="__codelineno-1-128" name="__codelineno-1-128" href="#__codelineno-1-128"></a>    void showPerson()
<a id="__codelineno-1-129" name="__codelineno-1-129" href="#__codelineno-1-129"></a>    {
<a id="__codelineno-1-130" name="__codelineno-1-130" href="#__codelineno-1-130"></a>        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
<a id="__codelineno-1-131" name="__codelineno-1-131" href="#__codelineno-1-131"></a>    }
<a id="__codelineno-1-132" name="__codelineno-1-132" href="#__codelineno-1-132"></a>public:
<a id="__codelineno-1-133" name="__codelineno-1-133" href="#__codelineno-1-133"></a>    NameType mName;
<a id="__codelineno-1-134" name="__codelineno-1-134" href="#__codelineno-1-134"></a>    AgeType mAge;
<a id="__codelineno-1-135" name="__codelineno-1-135" href="#__codelineno-1-135"></a>};
<a id="__codelineno-1-136" name="__codelineno-1-136" href="#__codelineno-1-136"></a>
<a id="__codelineno-1-137" name="__codelineno-1-137" href="#__codelineno-1-137"></a>void test01()
<a id="__codelineno-1-138" name="__codelineno-1-138" href="#__codelineno-1-138"></a>{
<a id="__codelineno-1-139" name="__codelineno-1-139" href="#__codelineno-1-139"></a>    // 指定NameType 为string类型，AgeType 为 int类型
<a id="__codelineno-1-140" name="__codelineno-1-140" href="#__codelineno-1-140"></a>    Person&lt;string, int&gt;P1(&quot;孙悟空&quot;, 999);
<a id="__codelineno-1-141" name="__codelineno-1-141" href="#__codelineno-1-141"></a>    P1.showPerson();
<a id="__codelineno-1-142" name="__codelineno-1-142" href="#__codelineno-1-142"></a>}
<a id="__codelineno-1-143" name="__codelineno-1-143" href="#__codelineno-1-143"></a>
<a id="__codelineno-1-144" name="__codelineno-1-144" href="#__codelineno-1-144"></a>int main() {
<a id="__codelineno-1-145" name="__codelineno-1-145" href="#__codelineno-1-145"></a>
<a id="__codelineno-1-146" name="__codelineno-1-146" href="#__codelineno-1-146"></a>    test01();
<a id="__codelineno-1-147" name="__codelineno-1-147" href="#__codelineno-1-147"></a>
<a id="__codelineno-1-148" name="__codelineno-1-148" href="#__codelineno-1-148"></a>    system(&quot;pause&quot;);
<a id="__codelineno-1-149" name="__codelineno-1-149" href="#__codelineno-1-149"></a>
<a id="__codelineno-1-150" name="__codelineno-1-150" href="#__codelineno-1-150"></a>    return 0;
<a id="__codelineno-1-151" name="__codelineno-1-151" href="#__codelineno-1-151"></a>}
<a id="__codelineno-1-152" name="__codelineno-1-152" href="#__codelineno-1-152"></a>``` **总结：** - 类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板
<a id="__codelineno-1-153" name="__codelineno-1-153" href="#__codelineno-1-153"></a>
<a id="__codelineno-1-154" name="__codelineno-1-154" href="#__codelineno-1-154"></a>#### 1.3.2 类模板与函数模板区别
<a id="__codelineno-1-155" name="__codelineno-1-155" href="#__codelineno-1-155"></a>
<a id="__codelineno-1-156" name="__codelineno-1-156" href="#__codelineno-1-156"></a>类模板与函数模板区别主要有两点：
<a id="__codelineno-1-157" name="__codelineno-1-157" href="#__codelineno-1-157"></a>
<a id="__codelineno-1-158" name="__codelineno-1-158" href="#__codelineno-1-158"></a>1. **类模板没有自动类型推导的使用方式** 2. 类模板在模板参数列表中 **可以有默认参数** 
<a id="__codelineno-1-159" name="__codelineno-1-159" href="#__codelineno-1-159"></a> **示例：** ```C++
<a id="__codelineno-1-160" name="__codelineno-1-160" href="#__codelineno-1-160"></a>#include &lt;string&gt;
<a id="__codelineno-1-161" name="__codelineno-1-161" href="#__codelineno-1-161"></a>//类模板
<a id="__codelineno-1-162" name="__codelineno-1-162" href="#__codelineno-1-162"></a>template&lt;class NameType, class AgeType = int&gt; 
<a id="__codelineno-1-163" name="__codelineno-1-163" href="#__codelineno-1-163"></a>class Person
<a id="__codelineno-1-164" name="__codelineno-1-164" href="#__codelineno-1-164"></a>{
<a id="__codelineno-1-165" name="__codelineno-1-165" href="#__codelineno-1-165"></a>public:
<a id="__codelineno-1-166" name="__codelineno-1-166" href="#__codelineno-1-166"></a>    Person(NameType name, AgeType age)
<a id="__codelineno-1-167" name="__codelineno-1-167" href="#__codelineno-1-167"></a>    {
<a id="__codelineno-1-168" name="__codelineno-1-168" href="#__codelineno-1-168"></a>        this-&gt;mName = name;
<a id="__codelineno-1-169" name="__codelineno-1-169" href="#__codelineno-1-169"></a>        this-&gt;mAge = age;
<a id="__codelineno-1-170" name="__codelineno-1-170" href="#__codelineno-1-170"></a>    }
<a id="__codelineno-1-171" name="__codelineno-1-171" href="#__codelineno-1-171"></a>    void showPerson()
<a id="__codelineno-1-172" name="__codelineno-1-172" href="#__codelineno-1-172"></a>    {
<a id="__codelineno-1-173" name="__codelineno-1-173" href="#__codelineno-1-173"></a>        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
<a id="__codelineno-1-174" name="__codelineno-1-174" href="#__codelineno-1-174"></a>    }
<a id="__codelineno-1-175" name="__codelineno-1-175" href="#__codelineno-1-175"></a>public:
<a id="__codelineno-1-176" name="__codelineno-1-176" href="#__codelineno-1-176"></a>    NameType mName;
<a id="__codelineno-1-177" name="__codelineno-1-177" href="#__codelineno-1-177"></a>    AgeType mAge;
<a id="__codelineno-1-178" name="__codelineno-1-178" href="#__codelineno-1-178"></a>};
<a id="__codelineno-1-179" name="__codelineno-1-179" href="#__codelineno-1-179"></a>
<a id="__codelineno-1-180" name="__codelineno-1-180" href="#__codelineno-1-180"></a>//1、类模板没有自动类型推导的使用方式
<a id="__codelineno-1-181" name="__codelineno-1-181" href="#__codelineno-1-181"></a>void test01()
<a id="__codelineno-1-182" name="__codelineno-1-182" href="#__codelineno-1-182"></a>{
<a id="__codelineno-1-183" name="__codelineno-1-183" href="#__codelineno-1-183"></a>    // Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导
<a id="__codelineno-1-184" name="__codelineno-1-184" href="#__codelineno-1-184"></a>    Person &lt;string ,int&gt;p(&quot;孙悟空&quot;, 1000); //必须使用显示指定类型的方式，使用类模板
<a id="__codelineno-1-185" name="__codelineno-1-185" href="#__codelineno-1-185"></a>    p.showPerson();
<a id="__codelineno-1-186" name="__codelineno-1-186" href="#__codelineno-1-186"></a>}
<a id="__codelineno-1-187" name="__codelineno-1-187" href="#__codelineno-1-187"></a>
<a id="__codelineno-1-188" name="__codelineno-1-188" href="#__codelineno-1-188"></a>//2、类模板在模板参数列表中可以有默认参数
<a id="__codelineno-1-189" name="__codelineno-1-189" href="#__codelineno-1-189"></a>void test02()
<a id="__codelineno-1-190" name="__codelineno-1-190" href="#__codelineno-1-190"></a>{
<a id="__codelineno-1-191" name="__codelineno-1-191" href="#__codelineno-1-191"></a>    Person &lt;string&gt; p(&quot;猪八戒&quot;, 999); //类模板中的模板参数列表 可以指定默认参数
<a id="__codelineno-1-192" name="__codelineno-1-192" href="#__codelineno-1-192"></a>    p.showPerson();
<a id="__codelineno-1-193" name="__codelineno-1-193" href="#__codelineno-1-193"></a>}
<a id="__codelineno-1-194" name="__codelineno-1-194" href="#__codelineno-1-194"></a>
<a id="__codelineno-1-195" name="__codelineno-1-195" href="#__codelineno-1-195"></a>int main() {
<a id="__codelineno-1-196" name="__codelineno-1-196" href="#__codelineno-1-196"></a>
<a id="__codelineno-1-197" name="__codelineno-1-197" href="#__codelineno-1-197"></a>    test01();
<a id="__codelineno-1-198" name="__codelineno-1-198" href="#__codelineno-1-198"></a>
<a id="__codelineno-1-199" name="__codelineno-1-199" href="#__codelineno-1-199"></a>    test02();
<a id="__codelineno-1-200" name="__codelineno-1-200" href="#__codelineno-1-200"></a>
<a id="__codelineno-1-201" name="__codelineno-1-201" href="#__codelineno-1-201"></a>    system(&quot;pause&quot;);
<a id="__codelineno-1-202" name="__codelineno-1-202" href="#__codelineno-1-202"></a>
<a id="__codelineno-1-203" name="__codelineno-1-203" href="#__codelineno-1-203"></a>    return 0;
<a id="__codelineno-1-204" name="__codelineno-1-204" href="#__codelineno-1-204"></a>}
<a id="__codelineno-1-205" name="__codelineno-1-205" href="#__codelineno-1-205"></a>``` **总结：** * 类模板使用只能用显示指定类型方式
<a id="__codelineno-1-206" name="__codelineno-1-206" href="#__codelineno-1-206"></a>* 类模板中的模板参数列表可以有默认参数
<a id="__codelineno-1-207" name="__codelineno-1-207" href="#__codelineno-1-207"></a>
<a id="__codelineno-1-208" name="__codelineno-1-208" href="#__codelineno-1-208"></a>#### 1.3.3 类模板中成员函数创建时机
<a id="__codelineno-1-209" name="__codelineno-1-209" href="#__codelineno-1-209"></a>
<a id="__codelineno-1-210" name="__codelineno-1-210" href="#__codelineno-1-210"></a>类模板中成员函数和普通类中成员函数创建时机是有区别的：
<a id="__codelineno-1-211" name="__codelineno-1-211" href="#__codelineno-1-211"></a>
<a id="__codelineno-1-212" name="__codelineno-1-212" href="#__codelineno-1-212"></a>* 普通类中的成员函数一开始就可以创建
<a id="__codelineno-1-213" name="__codelineno-1-213" href="#__codelineno-1-213"></a>* 类模板中的成员函数在调用时才创建 **示例：** ```C++
<a id="__codelineno-1-214" name="__codelineno-1-214" href="#__codelineno-1-214"></a>class Person1
<a id="__codelineno-1-215" name="__codelineno-1-215" href="#__codelineno-1-215"></a>{
<a id="__codelineno-1-216" name="__codelineno-1-216" href="#__codelineno-1-216"></a>public:
<a id="__codelineno-1-217" name="__codelineno-1-217" href="#__codelineno-1-217"></a>    void showPerson1()
<a id="__codelineno-1-218" name="__codelineno-1-218" href="#__codelineno-1-218"></a>    {
<a id="__codelineno-1-219" name="__codelineno-1-219" href="#__codelineno-1-219"></a>        cout &lt;&lt; &quot;Person1 show&quot; &lt;&lt; endl;
<a id="__codelineno-1-220" name="__codelineno-1-220" href="#__codelineno-1-220"></a>    }
<a id="__codelineno-1-221" name="__codelineno-1-221" href="#__codelineno-1-221"></a>};
<a id="__codelineno-1-222" name="__codelineno-1-222" href="#__codelineno-1-222"></a>
<a id="__codelineno-1-223" name="__codelineno-1-223" href="#__codelineno-1-223"></a>class Person2
<a id="__codelineno-1-224" name="__codelineno-1-224" href="#__codelineno-1-224"></a>{
<a id="__codelineno-1-225" name="__codelineno-1-225" href="#__codelineno-1-225"></a>public:
<a id="__codelineno-1-226" name="__codelineno-1-226" href="#__codelineno-1-226"></a>    void showPerson2()
<a id="__codelineno-1-227" name="__codelineno-1-227" href="#__codelineno-1-227"></a>    {
<a id="__codelineno-1-228" name="__codelineno-1-228" href="#__codelineno-1-228"></a>        cout &lt;&lt; &quot;Person2 show&quot; &lt;&lt; endl;
<a id="__codelineno-1-229" name="__codelineno-1-229" href="#__codelineno-1-229"></a>    }
<a id="__codelineno-1-230" name="__codelineno-1-230" href="#__codelineno-1-230"></a>};
<a id="__codelineno-1-231" name="__codelineno-1-231" href="#__codelineno-1-231"></a>
<a id="__codelineno-1-232" name="__codelineno-1-232" href="#__codelineno-1-232"></a>template&lt;class T&gt;
<a id="__codelineno-1-233" name="__codelineno-1-233" href="#__codelineno-1-233"></a>class MyClass
<a id="__codelineno-1-234" name="__codelineno-1-234" href="#__codelineno-1-234"></a>{
<a id="__codelineno-1-235" name="__codelineno-1-235" href="#__codelineno-1-235"></a>public:
<a id="__codelineno-1-236" name="__codelineno-1-236" href="#__codelineno-1-236"></a>    T obj;
<a id="__codelineno-1-237" name="__codelineno-1-237" href="#__codelineno-1-237"></a>
<a id="__codelineno-1-238" name="__codelineno-1-238" href="#__codelineno-1-238"></a>    //类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成
<a id="__codelineno-1-239" name="__codelineno-1-239" href="#__codelineno-1-239"></a>
<a id="__codelineno-1-240" name="__codelineno-1-240" href="#__codelineno-1-240"></a>    void fun1() { obj.showPerson1(); }
<a id="__codelineno-1-241" name="__codelineno-1-241" href="#__codelineno-1-241"></a>    void fun2() { obj.showPerson2(); }
<a id="__codelineno-1-242" name="__codelineno-1-242" href="#__codelineno-1-242"></a>
<a id="__codelineno-1-243" name="__codelineno-1-243" href="#__codelineno-1-243"></a>};
<a id="__codelineno-1-244" name="__codelineno-1-244" href="#__codelineno-1-244"></a>
<a id="__codelineno-1-245" name="__codelineno-1-245" href="#__codelineno-1-245"></a>void test01()
<a id="__codelineno-1-246" name="__codelineno-1-246" href="#__codelineno-1-246"></a>{
<a id="__codelineno-1-247" name="__codelineno-1-247" href="#__codelineno-1-247"></a>    MyClass&lt;Person1&gt; m;
<a id="__codelineno-1-248" name="__codelineno-1-248" href="#__codelineno-1-248"></a>
<a id="__codelineno-1-249" name="__codelineno-1-249" href="#__codelineno-1-249"></a>    m.fun1();
<a id="__codelineno-1-250" name="__codelineno-1-250" href="#__codelineno-1-250"></a>
<a id="__codelineno-1-251" name="__codelineno-1-251" href="#__codelineno-1-251"></a>    //m.fun2();//编译会出错，说明函数调用才会去创建成员函数
<a id="__codelineno-1-252" name="__codelineno-1-252" href="#__codelineno-1-252"></a>}
<a id="__codelineno-1-253" name="__codelineno-1-253" href="#__codelineno-1-253"></a>
<a id="__codelineno-1-254" name="__codelineno-1-254" href="#__codelineno-1-254"></a>int main() {
<a id="__codelineno-1-255" name="__codelineno-1-255" href="#__codelineno-1-255"></a>
<a id="__codelineno-1-256" name="__codelineno-1-256" href="#__codelineno-1-256"></a>    test01();
<a id="__codelineno-1-257" name="__codelineno-1-257" href="#__codelineno-1-257"></a>
<a id="__codelineno-1-258" name="__codelineno-1-258" href="#__codelineno-1-258"></a>    system(&quot;pause&quot;);
<a id="__codelineno-1-259" name="__codelineno-1-259" href="#__codelineno-1-259"></a>
<a id="__codelineno-1-260" name="__codelineno-1-260" href="#__codelineno-1-260"></a>    return 0;
<a id="__codelineno-1-261" name="__codelineno-1-261" href="#__codelineno-1-261"></a>}
<a id="__codelineno-1-262" name="__codelineno-1-262" href="#__codelineno-1-262"></a>``` **总结：** - 类模板中的成员函数并不是一开始就创建的，在调用时才去创建。
<a id="__codelineno-1-263" name="__codelineno-1-263" href="#__codelineno-1-263"></a>
<a id="__codelineno-1-264" name="__codelineno-1-264" href="#__codelineno-1-264"></a>#### 1.3.4 类模板对象做函数参数
<a id="__codelineno-1-265" name="__codelineno-1-265" href="#__codelineno-1-265"></a>
<a id="__codelineno-1-266" name="__codelineno-1-266" href="#__codelineno-1-266"></a>学习目标：
<a id="__codelineno-1-267" name="__codelineno-1-267" href="#__codelineno-1-267"></a>
<a id="__codelineno-1-268" name="__codelineno-1-268" href="#__codelineno-1-268"></a>* 类模板实例化出的对象，向函数传参的方式
<a id="__codelineno-1-269" name="__codelineno-1-269" href="#__codelineno-1-269"></a>
<a id="__codelineno-1-270" name="__codelineno-1-270" href="#__codelineno-1-270"></a>一共有三种传入方式：
<a id="__codelineno-1-271" name="__codelineno-1-271" href="#__codelineno-1-271"></a>
<a id="__codelineno-1-272" name="__codelineno-1-272" href="#__codelineno-1-272"></a>1. 指定传入的类型   --- 直接显示对象的数据类型
<a id="__codelineno-1-273" name="__codelineno-1-273" href="#__codelineno-1-273"></a>2. 参数模板化           --- 将对象中的参数变为模板进行传递
<a id="__codelineno-1-274" name="__codelineno-1-274" href="#__codelineno-1-274"></a>3. 整个类模板化       --- 将这个对象类型 模板化进行传递 **示例：** ```C++
<a id="__codelineno-1-275" name="__codelineno-1-275" href="#__codelineno-1-275"></a>#include &lt;string&gt;
<a id="__codelineno-1-276" name="__codelineno-1-276" href="#__codelineno-1-276"></a>//类模板
<a id="__codelineno-1-277" name="__codelineno-1-277" href="#__codelineno-1-277"></a>template&lt;class NameType, class AgeType = int&gt; 
<a id="__codelineno-1-278" name="__codelineno-1-278" href="#__codelineno-1-278"></a>class Person
<a id="__codelineno-1-279" name="__codelineno-1-279" href="#__codelineno-1-279"></a>{
<a id="__codelineno-1-280" name="__codelineno-1-280" href="#__codelineno-1-280"></a>public:
<a id="__codelineno-1-281" name="__codelineno-1-281" href="#__codelineno-1-281"></a>    Person(NameType name, AgeType age)
<a id="__codelineno-1-282" name="__codelineno-1-282" href="#__codelineno-1-282"></a>    {
<a id="__codelineno-1-283" name="__codelineno-1-283" href="#__codelineno-1-283"></a>        this-&gt;mName = name;
<a id="__codelineno-1-284" name="__codelineno-1-284" href="#__codelineno-1-284"></a>        this-&gt;mAge = age;
<a id="__codelineno-1-285" name="__codelineno-1-285" href="#__codelineno-1-285"></a>    }
<a id="__codelineno-1-286" name="__codelineno-1-286" href="#__codelineno-1-286"></a>    void showPerson()
<a id="__codelineno-1-287" name="__codelineno-1-287" href="#__codelineno-1-287"></a>    {
<a id="__codelineno-1-288" name="__codelineno-1-288" href="#__codelineno-1-288"></a>        cout &lt;&lt; &quot;name: &quot; &lt;&lt; this-&gt;mName &lt;&lt; &quot; age: &quot; &lt;&lt; this-&gt;mAge &lt;&lt; endl;
<a id="__codelineno-1-289" name="__codelineno-1-289" href="#__codelineno-1-289"></a>    }
<a id="__codelineno-1-290" name="__codelineno-1-290" href="#__codelineno-1-290"></a>public:
<a id="__codelineno-1-291" name="__codelineno-1-291" href="#__codelineno-1-291"></a>    NameType mName;
<a id="__codelineno-1-292" name="__codelineno-1-292" href="#__codelineno-1-292"></a>    AgeType mAge;
<a id="__codelineno-1-293" name="__codelineno-1-293" href="#__codelineno-1-293"></a>};
<a id="__codelineno-1-294" name="__codelineno-1-294" href="#__codelineno-1-294"></a>
<a id="__codelineno-1-295" name="__codelineno-1-295" href="#__codelineno-1-295"></a>//1、指定传入的类型
<a id="__codelineno-1-296" name="__codelineno-1-296" href="#__codelineno-1-296"></a>void printPerson1(Person&lt;string, int&gt; &amp;p) 
<a id="__codelineno-1-297" name="__codelineno-1-297" href="#__codelineno-1-297"></a>{
<a id="__codelineno-1-298" name="__codelineno-1-298" href="#__codelineno-1-298"></a>    p.showPerson();
<a id="__codelineno-1-299" name="__codelineno-1-299" href="#__codelineno-1-299"></a>}
<a id="__codelineno-1-300" name="__codelineno-1-300" href="#__codelineno-1-300"></a>void test01()
<a id="__codelineno-1-301" name="__codelineno-1-301" href="#__codelineno-1-301"></a>{
<a id="__codelineno-1-302" name="__codelineno-1-302" href="#__codelineno-1-302"></a>    Person &lt;string, int &gt;p(&quot;孙悟空&quot;, 100);
<a id="__codelineno-1-303" name="__codelineno-1-303" href="#__codelineno-1-303"></a>    printPerson1(p);
<a id="__codelineno-1-304" name="__codelineno-1-304" href="#__codelineno-1-304"></a>}
<a id="__codelineno-1-305" name="__codelineno-1-305" href="#__codelineno-1-305"></a>
<a id="__codelineno-1-306" name="__codelineno-1-306" href="#__codelineno-1-306"></a>//2、参数模板化
<a id="__codelineno-1-307" name="__codelineno-1-307" href="#__codelineno-1-307"></a>template &lt;class T1, class T2&gt;
<a id="__codelineno-1-308" name="__codelineno-1-308" href="#__codelineno-1-308"></a>void printPerson2(Person&lt;T1, T2&gt;&amp;p)
<a id="__codelineno-1-309" name="__codelineno-1-309" href="#__codelineno-1-309"></a>{
<a id="__codelineno-1-310" name="__codelineno-1-310" href="#__codelineno-1-310"></a>    p.showPerson();
<a id="__codelineno-1-311" name="__codelineno-1-311" href="#__codelineno-1-311"></a>    cout &lt;&lt; &quot;T1的类型为： &quot; &lt;&lt; typeid(T1).name() &lt;&lt; endl;
<a id="__codelineno-1-312" name="__codelineno-1-312" href="#__codelineno-1-312"></a>    cout &lt;&lt; &quot;T2的类型为： &quot; &lt;&lt; typeid(T2).name() &lt;&lt; endl;
<a id="__codelineno-1-313" name="__codelineno-1-313" href="#__codelineno-1-313"></a>}
<a id="__codelineno-1-314" name="__codelineno-1-314" href="#__codelineno-1-314"></a>void test02()
<a id="__codelineno-1-315" name="__codelineno-1-315" href="#__codelineno-1-315"></a>{
<a id="__codelineno-1-316" name="__codelineno-1-316" href="#__codelineno-1-316"></a>    Person &lt;string, int &gt;p(&quot;猪八戒&quot;, 90);
<a id="__codelineno-1-317" name="__codelineno-1-317" href="#__codelineno-1-317"></a>    printPerson2(p);
<a id="__codelineno-1-318" name="__codelineno-1-318" href="#__codelineno-1-318"></a>}
<a id="__codelineno-1-319" name="__codelineno-1-319" href="#__codelineno-1-319"></a>
<a id="__codelineno-1-320" name="__codelineno-1-320" href="#__codelineno-1-320"></a>//3、整个类模板化
<a id="__codelineno-1-321" name="__codelineno-1-321" href="#__codelineno-1-321"></a>template&lt;class T&gt;
<a id="__codelineno-1-322" name="__codelineno-1-322" href="#__codelineno-1-322"></a>void printPerson3(T &amp; p)
<a id="__codelineno-1-323" name="__codelineno-1-323" href="#__codelineno-1-323"></a>{
<a id="__codelineno-1-324" name="__codelineno-1-324" href="#__codelineno-1-324"></a>    cout &lt;&lt; &quot;T的类型为： &quot; &lt;&lt; typeid(T).name() &lt;&lt; endl;
<a id="__codelineno-1-325" name="__codelineno-1-325" href="#__codelineno-1-325"></a>    p.showPerson();
<a id="__codelineno-1-326" name="__codelineno-1-326" href="#__codelineno-1-326"></a>
<a id="__codelineno-1-327" name="__codelineno-1-327" href="#__codelineno-1-327"></a>}
<a id="__codelineno-1-328" name="__codelineno-1-328" href="#__codelineno-1-328"></a>void test03()
<a id="__codelineno-1-329" name="__codelineno-1-329" href="#__codelineno-1-329"></a>{
<a id="__codelineno-1-330" name="__codelineno-1-330" href="#__codelineno-1-330"></a>    Person &lt;string, int &gt;p(&quot;唐僧&quot;, 30);
<a id="__codelineno-1-331" name="__codelineno-1-331" href="#__codelineno-1-331"></a>    printPerson3(p);
<a id="__codelineno-1-332" name="__codelineno-1-332" href="#__codelineno-1-332"></a>}
<a id="__codelineno-1-333" name="__codelineno-1-333" href="#__codelineno-1-333"></a>
<a id="__codelineno-1-334" name="__codelineno-1-334" href="#__codelineno-1-334"></a>int main() {
<a id="__codelineno-1-335" name="__codelineno-1-335" href="#__codelineno-1-335"></a>
<a id="__codelineno-1-336" name="__codelineno-1-336" href="#__codelineno-1-336"></a>    test01();
<a id="__codelineno-1-337" name="__codelineno-1-337" href="#__codelineno-1-337"></a>    test02();
<a id="__codelineno-1-338" name="__codelineno-1-338" href="#__codelineno-1-338"></a>    test03();
<a id="__codelineno-1-339" name="__codelineno-1-339" href="#__codelineno-1-339"></a>
<a id="__codelineno-1-340" name="__codelineno-1-340" href="#__codelineno-1-340"></a>    system(&quot;pause&quot;);
<a id="__codelineno-1-341" name="__codelineno-1-341" href="#__codelineno-1-341"></a>
<a id="__codelineno-1-342" name="__codelineno-1-342" href="#__codelineno-1-342"></a>    return 0;
<a id="__codelineno-1-343" name="__codelineno-1-343" href="#__codelineno-1-343"></a>}
<a id="__codelineno-1-344" name="__codelineno-1-344" href="#__codelineno-1-344"></a>``` **总结：** * 通过类模板创建的对象，可以有三种方式向函数中进行传参
<a id="__codelineno-1-345" name="__codelineno-1-345" href="#__codelineno-1-345"></a>* 使用比较广泛是第一种：指定传入的类型
<a id="__codelineno-1-346" name="__codelineno-1-346" href="#__codelineno-1-346"></a>
<a id="__codelineno-1-347" name="__codelineno-1-347" href="#__codelineno-1-347"></a>#### 1.3.5 类模板与继承
<a id="__codelineno-1-348" name="__codelineno-1-348" href="#__codelineno-1-348"></a>
<a id="__codelineno-1-349" name="__codelineno-1-349" href="#__codelineno-1-349"></a>当类模板碰到继承时，需要注意一下几点：
<a id="__codelineno-1-350" name="__codelineno-1-350" href="#__codelineno-1-350"></a>
<a id="__codelineno-1-351" name="__codelineno-1-351" href="#__codelineno-1-351"></a>* 当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型
<a id="__codelineno-1-352" name="__codelineno-1-352" href="#__codelineno-1-352"></a>* 如果不指定，编译器无法给子类分配内存
<a id="__codelineno-1-353" name="__codelineno-1-353" href="#__codelineno-1-353"></a>* 如果想灵活指定出父类中T的类型，子类也需变为类模板 **示例：** ```C++
<a id="__codelineno-1-354" name="__codelineno-1-354" href="#__codelineno-1-354"></a>template&lt;class T&gt;
<a id="__codelineno-1-355" name="__codelineno-1-355" href="#__codelineno-1-355"></a>class Base
<a id="__codelineno-1-356" name="__codelineno-1-356" href="#__codelineno-1-356"></a>{
<a id="__codelineno-1-357" name="__codelineno-1-357" href="#__codelineno-1-357"></a>    T m;
<a id="__codelineno-1-358" name="__codelineno-1-358" href="#__codelineno-1-358"></a>};
<a id="__codelineno-1-359" name="__codelineno-1-359" href="#__codelineno-1-359"></a>
<a id="__codelineno-1-360" name="__codelineno-1-360" href="#__codelineno-1-360"></a>//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承
<a id="__codelineno-1-361" name="__codelineno-1-361" href="#__codelineno-1-361"></a>class Son :public Base&lt;int&gt; //必须指定一个类型
<a id="__codelineno-1-362" name="__codelineno-1-362" href="#__codelineno-1-362"></a>{
<a id="__codelineno-1-363" name="__codelineno-1-363" href="#__codelineno-1-363"></a>};
<a id="__codelineno-1-364" name="__codelineno-1-364" href="#__codelineno-1-364"></a>void test01()
<a id="__codelineno-1-365" name="__codelineno-1-365" href="#__codelineno-1-365"></a>{
<a id="__codelineno-1-366" name="__codelineno-1-366" href="#__codelineno-1-366"></a>    Son c;
<a id="__codelineno-1-367" name="__codelineno-1-367" href="#__codelineno-1-367"></a>}
<a id="__codelineno-1-368" name="__codelineno-1-368" href="#__codelineno-1-368"></a>
<a id="__codelineno-1-369" name="__codelineno-1-369" href="#__codelineno-1-369"></a>//类模板继承类模板 ,可以用T2指定父类中的T类型
<a id="__codelineno-1-370" name="__codelineno-1-370" href="#__codelineno-1-370"></a>template&lt;class T1, class T2&gt;
<a id="__codelineno-1-371" name="__codelineno-1-371" href="#__codelineno-1-371"></a>class Son2 :public Base&lt;T2&gt;
<a id="__codelineno-1-372" name="__codelineno-1-372" href="#__codelineno-1-372"></a>{
<a id="__codelineno-1-373" name="__codelineno-1-373" href="#__codelineno-1-373"></a>public:
<a id="__codelineno-1-374" name="__codelineno-1-374" href="#__codelineno-1-374"></a>    Son2()
<a id="__codelineno-1-375" name="__codelineno-1-375" href="#__codelineno-1-375"></a>    {
<a id="__codelineno-1-376" name="__codelineno-1-376" href="#__codelineno-1-376"></a>        cout &lt;&lt; typeid(T1).name() &lt;&lt; endl;
<a id="__codelineno-1-377" name="__codelineno-1-377" href="#__codelineno-1-377"></a>        cout &lt;&lt; typeid(T2).name() &lt;&lt; endl;
<a id="__codelineno-1-378" name="__codelineno-1-378" href="#__codelineno-1-378"></a>    }
<a id="__codelineno-1-379" name="__codelineno-1-379" href="#__codelineno-1-379"></a>};
<a id="__codelineno-1-380" name="__codelineno-1-380" href="#__codelineno-1-380"></a>
<a id="__codelineno-1-381" name="__codelineno-1-381" href="#__codelineno-1-381"></a>void test02()
<a id="__codelineno-1-382" name="__codelineno-1-382" href="#__codelineno-1-382"></a>{
<a id="__codelineno-1-383" name="__codelineno-1-383" href="#__codelineno-1-383"></a>    Son2&lt;int, char&gt; child1;
<a id="__codelineno-1-384" name="__codelineno-1-384" href="#__codelineno-1-384"></a>}
<a id="__codelineno-1-385" name="__codelineno-1-385" href="#__codelineno-1-385"></a>
<a id="__codelineno-1-386" name="__codelineno-1-386" href="#__codelineno-1-386"></a>
<a id="__codelineno-1-387" name="__codelineno-1-387" href="#__codelineno-1-387"></a>int main() {
<a id="__codelineno-1-388" name="__codelineno-1-388" href="#__codelineno-1-388"></a>
<a id="__codelineno-1-389" name="__codelineno-1-389" href="#__codelineno-1-389"></a>    test01();
<a id="__codelineno-1-390" name="__codelineno-1-390" href="#__codelineno-1-390"></a>
<a id="__codelineno-1-391" name="__codelineno-1-391" href="#__codelineno-1-391"></a>    test02();
<a id="__codelineno-1-392" name="__codelineno-1-392" href="#__codelineno-1-392"></a>
<a id="__codelineno-1-393" name="__codelineno-1-393" href="#__codelineno-1-393"></a>    system(&quot;pause&quot;);
<a id="__codelineno-1-394" name="__codelineno-1-394" href="#__codelineno-1-394"></a>
<a id="__codelineno-1-395" name="__codelineno-1-395" href="#__codelineno-1-395"></a>    return 0;
<a id="__codelineno-1-396" name="__codelineno-1-396" href="#__codelineno-1-396"></a>}
</code></pre></div></p>
<p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型。</p>
<h4 id="136">1.3.6 类模板成员函数类外实现<a class="headerlink" href="#136" title="Permanent link">&para;</a></h4>
<p>学习目标：能够掌握类模板中的成员函数类外实现。 <strong>示例：</strong> ```C++</p>
<h1 id="include">include <string><a class="headerlink" href="#include" title="Permanent link">&para;</a></h1>
<p>//类模板中成员函数类外实现
template<class T1, class T2>
class Person {
public:
    //成员函数类内声明
    Person(T1 name, T2 age);
    void showPerson();</p>
<p>public:
    T1 m_Name;
    T2 m_Age;
};</p>
<p>//构造函数 类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) {
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
}</p>
<p>//成员函数 类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
    cout &lt;&lt; "姓名: " &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
}</p>
<p>void test01()
{
    Person<string, int> p("Tom", 20);
    p.showPerson();
}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：类模板中成员函数类外实现时，需要加上模板参数列表。
</p>
<h4 id="137">1.3.7 类模板分文件编写<a class="headerlink" href="#137" title="Permanent link">&para;</a></h4>
<p>学习目标：

* 掌握类模板成员函数分文件编写产生的问题以及解决方式

问题：

* 类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到


解决：

* 解决方式1：直接包含.cpp源文件
* 解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制
 <strong>示例：</strong> person.hpp中代码：

```C++</p>
<h1 id="pragma-once">pragma once<a class="headerlink" href="#pragma-once" title="Permanent link">&para;</a></h1>
<h1 id="include_1">include <iostream><a class="headerlink" href="#include_1" title="Permanent link">&para;</a></h1>
<p>using namespace std;</p>
<h1 id="include_2">include <string><a class="headerlink" href="#include_2" title="Permanent link">&para;</a></h1>
<p>template<class T1, class T2>
class Person {
public:
    Person(T1 name, T2 age);
    void showPerson();
public:
    T1 m_Name;
    T2 m_Age;
};

//构造函数 类外实现
template<class T1, class T2>
Person<T1, T2>::Person(T1 name, T2 age) {
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
}

//成员函数 类外实现
template<class T1, class T2>
void Person<T1, T2>::showPerson() {
    cout &lt;&lt; "姓名: " &lt;&lt; this-&gt;m_Name &lt;&lt; " 年龄:" &lt;&lt; this-&gt;m_Age &lt;&lt; endl;
}
```</p>
<p>类模板分文件编写.cpp中代码</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-3-1" name="__codelineno-3-1" href="#__codelineno-3-1"></a><span class="cp">#include</span><span class="cpf">&lt;iostream&gt;</span>
<a id="__codelineno-3-2" name="__codelineno-3-2" href="#__codelineno-3-2"></a><span class="k">using</span><span class="w"> </span><span class="k">namespace</span><span class="w"> </span><span class="nn">std</span><span class="p">;</span>
<a id="__codelineno-3-3" name="__codelineno-3-3" href="#__codelineno-3-3"></a>
<a id="__codelineno-3-4" name="__codelineno-3-4" href="#__codelineno-3-4"></a><span class="c1">//#include &quot;person.h&quot;</span>
<a id="__codelineno-3-5" name="__codelineno-3-5" href="#__codelineno-3-5"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;person.cpp&quot;</span><span class="c1"> //解决方式1，包含cpp源文件</span>
<a id="__codelineno-3-6" name="__codelineno-3-6" href="#__codelineno-3-6"></a>
<a id="__codelineno-3-7" name="__codelineno-3-7" href="#__codelineno-3-7"></a><span class="c1">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span>
<a id="__codelineno-3-8" name="__codelineno-3-8" href="#__codelineno-3-8"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;person.hpp&quot;</span>
<a id="__codelineno-3-9" name="__codelineno-3-9" href="#__codelineno-3-9"></a><span class="kt">void</span><span class="w"> </span><span class="nf">test01</span><span class="p">()</span>
<a id="__codelineno-3-10" name="__codelineno-3-10" href="#__codelineno-3-10"></a><span class="p">{</span>
<a id="__codelineno-3-11" name="__codelineno-3-11" href="#__codelineno-3-11"></a><span class="w">    </span><span class="n">Person</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">p</span><span class="p">(</span><span class="s">&quot;Tom&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-3-12" name="__codelineno-3-12" href="#__codelineno-3-12"></a><span class="w">    </span><span class="n">p</span><span class="p">.</span><span class="n">showPerson</span><span class="p">();</span>
<a id="__codelineno-3-13" name="__codelineno-3-13" href="#__codelineno-3-13"></a><span class="p">}</span>
<a id="__codelineno-3-14" name="__codelineno-3-14" href="#__codelineno-3-14"></a>
<a id="__codelineno-3-15" name="__codelineno-3-15" href="#__codelineno-3-15"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-3-16" name="__codelineno-3-16" href="#__codelineno-3-16"></a>
<a id="__codelineno-3-17" name="__codelineno-3-17" href="#__codelineno-3-17"></a><span class="w">    </span><span class="n">test01</span><span class="p">();</span>
<a id="__codelineno-3-18" name="__codelineno-3-18" href="#__codelineno-3-18"></a>
<a id="__codelineno-3-19" name="__codelineno-3-19" href="#__codelineno-3-19"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-3-20" name="__codelineno-3-20" href="#__codelineno-3-20"></a>
<a id="__codelineno-3-21" name="__codelineno-3-21" href="#__codelineno-3-21"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-3-22" name="__codelineno-3-22" href="#__codelineno-3-22"></a><span class="p">}</span>
</code></pre></div>
<p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp 。</p>
<h4 id="138">1.3.8 类模板与友元<a class="headerlink" href="#138" title="Permanent link">&para;</a></h4>
<p>学习目标：</p>
<ul>
<li>掌握类模板配合友元函数的类内和类外实现</li>
</ul>
<p>全局函数类内实现 - 直接在类内声明友元即可</p>
<p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在 <strong>示例：</strong> ```C++</p>
<h1 id="include_3">include <string><a class="headerlink" href="#include_3" title="Permanent link">&para;</a></h1>
<p>//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元
template<class T1, class T2> class Person;</p>
<p>//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到
//template<class T1, class T2> void printPerson2(Person<T1, T2> &amp; p); </p>
<p>template<class T1, class T2>
void printPerson2(Person<T1, T2> &amp; p)
{
    cout &lt;&lt; "类外实现 ---- 姓名： " &lt;&lt; p.m_Name &lt;&lt; " 年龄：" &lt;&lt; p.m_Age &lt;&lt; endl;
}</p>
<p>template<class T1, class T2>
class Person
{
    //1、全局函数配合友元   类内实现
    friend void printPerson(Person<T1, T2> &amp; p)
    {
        cout &lt;&lt; "姓名： " &lt;&lt; p.m_Name &lt;&lt; " 年龄：" &lt;&lt; p.m_Age &lt;&lt; endl;
    }</p>
<div class="highlight"><pre><span></span><code>//全局函数配合友元  类外实现
friend void printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);
</code></pre></div>
<p>public:</p>
<div class="highlight"><pre><span></span><code>Person(T1 name, T2 age)
{
    this-&gt;m_Name = name;
    this-&gt;m_Age = age;
}
</code></pre></div>
<p>private:
    T1 m_Name;
    T2 m_Age;</p>
<p>};</p>
<p>//1、全局函数在类内实现
void test01()
{
    Person <string, int >p("Tom", 20);
    printPerson(p);
}</p>
<p>//2、全局函数在类外实现
void test02()
{
    Person <string, int >p("Jerry", 30);
    printPerson2(p);
}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>//test01();

test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别。
</p>
<h4 id="139">1.3.9 类模板案例<a class="headerlink" href="#139" title="Permanent link">&para;</a></h4>
<p>案例描述:  实现一个通用的数组类，要求如下：

* 可以对内置数据类型以及自定义数据类型的数据进行存储
* 将数组中的数据存储到堆区
* 构造函数中可以传入数组的容量
* 提供对应的拷贝构造函数以及operator=防止浅拷贝问题
* 提供尾插法和尾删法对数组中的数据进行增加和删除
* 可以通过下标的方式访问数组中的元素
* 可以获取数组中当前元素个数和数组的容量 <strong>示例：</strong> myArray.hpp中代码

```C++</p>
<h1 id="pragma-once_1">pragma once<a class="headerlink" href="#pragma-once_1" title="Permanent link">&para;</a></h1>
<h1 id="include_4">include <iostream><a class="headerlink" href="#include_4" title="Permanent link">&para;</a></h1>
<p>using namespace std;

template<class T>
class MyArray
{
public:

    //构造函数
    MyArray(int capacity)
    {
        this-&gt;m_Capacity = capacity;
        this-&gt;m_Size = 0;
        pAddress = new T[this-&gt;m_Capacity];
    }

    //拷贝构造
    MyArray(const MyArray &amp; arr)
    {
        this-&gt;m_Capacity = arr.m_Capacity;
        this-&gt;m_Size = arr.m_Size;
        this-&gt;pAddress = new T[this-&gt;m_Capacity];
        for (int i = 0; i &lt; this-&gt;m_Size; i++)
        {
            //如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，
            // 普通类型可以直接= 但是指针类型需要深拷贝
            this-&gt;pAddress[i] = arr.pAddress[i];
        }
    }

    //重载= 操作符  防止浅拷贝问题
    MyArray&amp; operator=(const MyArray&amp; myarray) {

        if (this-&gt;pAddress != NULL) {
            delete[] this-&gt;pAddress;
            this-&gt;m_Capacity = 0;
            this-&gt;m_Size = 0;
        }

        this-&gt;m_Capacity = myarray.m_Capacity;
        this-&gt;m_Size = myarray.m_Size;
        this-&gt;pAddress = new T[this-&gt;m_Capacity];
        for (int i = 0; i &lt; this-&gt;m_Size; i++) {
            this-&gt;pAddress[i] = myarray[i];
        }
        return *this;
    }

    //重载[] 操作符  arr[0]
    T&amp; operator <a href="int index"></a>
    {
        return this-&gt;pAddress[index]; //不考虑越界，用户自己去处理
    }

    //尾插法
    void Push_back(const T &amp; val)
    {
        if (this-&gt;m_Capacity == this-&gt;m_Size)
        {
            return;
        }
        this-&gt;pAddress[this-&gt;m_Size] = val;
        this-&gt;m_Size++;
    }

    //尾删法
    void Pop_back()
    {
        if (this-&gt;m_Size == 0)
        {
            return;
        }
        this-&gt;m_Size--;
    }

    //获取数组容量
    int getCapacity()
    {
        return this-&gt;m_Capacity;
    }

    //获取数组大小
    int getSize()
    {
        return this-&gt;m_Size;
    }


    //析构
    ~MyArray()
    {
        if (this-&gt;pAddress != NULL)
        {
            delete[] this-&gt;pAddress;
            this-&gt;pAddress = NULL;
            this-&gt;m_Capacity = 0;
            this-&gt;m_Size = 0;
        }
    }

private:
    T * pAddress;  //指向一个堆空间，这个空间存储真正的数据
    int m_Capacity; //容量
    int m_Size;   // 大小
};
```</p>
<p>类模板案例—数组类封装.cpp中</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-5-1" name="__codelineno-5-1" href="#__codelineno-5-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;myArray.hpp&quot;</span>
<a id="__codelineno-5-2" name="__codelineno-5-2" href="#__codelineno-5-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<a id="__codelineno-5-3" name="__codelineno-5-3" href="#__codelineno-5-3"></a>
<a id="__codelineno-5-4" name="__codelineno-5-4" href="#__codelineno-5-4"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printIntArray</span><span class="p">(</span><span class="n">MyArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">arr</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-5" name="__codelineno-5-5" href="#__codelineno-5-5"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-6" name="__codelineno-5-6" href="#__codelineno-5-6"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-5-7" name="__codelineno-5-7" href="#__codelineno-5-7"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-5-8" name="__codelineno-5-8" href="#__codelineno-5-8"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-9" name="__codelineno-5-9" href="#__codelineno-5-9"></a><span class="p">}</span>
<a id="__codelineno-5-10" name="__codelineno-5-10" href="#__codelineno-5-10"></a>
<a id="__codelineno-5-11" name="__codelineno-5-11" href="#__codelineno-5-11"></a><span class="c1">//测试内置数据类型</span>
<a id="__codelineno-5-12" name="__codelineno-5-12" href="#__codelineno-5-12"></a><span class="kt">void</span><span class="w"> </span><span class="nf">test01</span><span class="p">()</span>
<a id="__codelineno-5-13" name="__codelineno-5-13" href="#__codelineno-5-13"></a><span class="p">{</span>
<a id="__codelineno-5-14" name="__codelineno-5-14" href="#__codelineno-5-14"></a><span class="w">    </span><span class="n">MyArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array1</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-5-15" name="__codelineno-5-15" href="#__codelineno-5-15"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-5-16" name="__codelineno-5-16" href="#__codelineno-5-16"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-5-17" name="__codelineno-5-17" href="#__codelineno-5-17"></a><span class="w">        </span><span class="n">array1</span><span class="p">.</span><span class="n">Push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<a id="__codelineno-5-18" name="__codelineno-5-18" href="#__codelineno-5-18"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-5-19" name="__codelineno-5-19" href="#__codelineno-5-19"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;array1打印输出：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-20" name="__codelineno-5-20" href="#__codelineno-5-20"></a><span class="w">    </span><span class="n">printIntArray</span><span class="p">(</span><span class="n">array1</span><span class="p">);</span>
<a id="__codelineno-5-21" name="__codelineno-5-21" href="#__codelineno-5-21"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;array1的大小：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array1</span><span class="p">.</span><span class="n">getSize</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-22" name="__codelineno-5-22" href="#__codelineno-5-22"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;array1的容量：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array1</span><span class="p">.</span><span class="n">getCapacity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-23" name="__codelineno-5-23" href="#__codelineno-5-23"></a>
<a id="__codelineno-5-24" name="__codelineno-5-24" href="#__codelineno-5-24"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;--------------------------&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-25" name="__codelineno-5-25" href="#__codelineno-5-25"></a>
<a id="__codelineno-5-26" name="__codelineno-5-26" href="#__codelineno-5-26"></a><span class="w">    </span><span class="n">MyArray</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">array2</span><span class="p">(</span><span class="n">array1</span><span class="p">);</span>
<a id="__codelineno-5-27" name="__codelineno-5-27" href="#__codelineno-5-27"></a><span class="w">    </span><span class="n">array2</span><span class="p">.</span><span class="n">Pop_back</span><span class="p">();</span>
<a id="__codelineno-5-28" name="__codelineno-5-28" href="#__codelineno-5-28"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;array2打印输出：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-29" name="__codelineno-5-29" href="#__codelineno-5-29"></a><span class="w">    </span><span class="n">printIntArray</span><span class="p">(</span><span class="n">array2</span><span class="p">);</span>
<a id="__codelineno-5-30" name="__codelineno-5-30" href="#__codelineno-5-30"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;array2的大小：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array2</span><span class="p">.</span><span class="n">getSize</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-31" name="__codelineno-5-31" href="#__codelineno-5-31"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;array2的容量：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">array2</span><span class="p">.</span><span class="n">getCapacity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-32" name="__codelineno-5-32" href="#__codelineno-5-32"></a><span class="p">}</span>
<a id="__codelineno-5-33" name="__codelineno-5-33" href="#__codelineno-5-33"></a>
<a id="__codelineno-5-34" name="__codelineno-5-34" href="#__codelineno-5-34"></a><span class="c1">//测试自定义数据类型</span>
<a id="__codelineno-5-35" name="__codelineno-5-35" href="#__codelineno-5-35"></a><span class="k">class</span><span class="w"> </span><span class="nc">Person</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-36" name="__codelineno-5-36" href="#__codelineno-5-36"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-5-37" name="__codelineno-5-37" href="#__codelineno-5-37"></a><span class="w">    </span><span class="n">Person</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span>
<a id="__codelineno-5-38" name="__codelineno-5-38" href="#__codelineno-5-38"></a><span class="w">        </span><span class="n">Person</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-39" name="__codelineno-5-39" href="#__codelineno-5-39"></a><span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<a id="__codelineno-5-40" name="__codelineno-5-40" href="#__codelineno-5-40"></a><span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<a id="__codelineno-5-41" name="__codelineno-5-41" href="#__codelineno-5-41"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-5-42" name="__codelineno-5-42" href="#__codelineno-5-42"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-5-43" name="__codelineno-5-43" href="#__codelineno-5-43"></a><span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">m_Name</span><span class="p">;</span>
<a id="__codelineno-5-44" name="__codelineno-5-44" href="#__codelineno-5-44"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m_Age</span><span class="p">;</span>
<a id="__codelineno-5-45" name="__codelineno-5-45" href="#__codelineno-5-45"></a><span class="p">};</span>
<a id="__codelineno-5-46" name="__codelineno-5-46" href="#__codelineno-5-46"></a>
<a id="__codelineno-5-47" name="__codelineno-5-47" href="#__codelineno-5-47"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printPersonArray</span><span class="p">(</span><span class="n">MyArray</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">personArr</span><span class="p">)</span>
<a id="__codelineno-5-48" name="__codelineno-5-48" href="#__codelineno-5-48"></a><span class="p">{</span>
<a id="__codelineno-5-49" name="__codelineno-5-49" href="#__codelineno-5-49"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">personArr</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-50" name="__codelineno-5-50" href="#__codelineno-5-50"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;姓名：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">personArr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">m_Name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; 年龄： &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">personArr</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">m_Age</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-51" name="__codelineno-5-51" href="#__codelineno-5-51"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-5-52" name="__codelineno-5-52" href="#__codelineno-5-52"></a>
<a id="__codelineno-5-53" name="__codelineno-5-53" href="#__codelineno-5-53"></a><span class="p">}</span>
<a id="__codelineno-5-54" name="__codelineno-5-54" href="#__codelineno-5-54"></a>
<a id="__codelineno-5-55" name="__codelineno-5-55" href="#__codelineno-5-55"></a><span class="kt">void</span><span class="w"> </span><span class="nf">test02</span><span class="p">()</span>
<a id="__codelineno-5-56" name="__codelineno-5-56" href="#__codelineno-5-56"></a><span class="p">{</span>
<a id="__codelineno-5-57" name="__codelineno-5-57" href="#__codelineno-5-57"></a><span class="w">    </span><span class="c1">//创建数组</span>
<a id="__codelineno-5-58" name="__codelineno-5-58" href="#__codelineno-5-58"></a><span class="w">    </span><span class="n">MyArray</span><span class="o">&lt;</span><span class="n">Person</span><span class="o">&gt;</span><span class="w"> </span><span class="n">pArray</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-5-59" name="__codelineno-5-59" href="#__codelineno-5-59"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p1</span><span class="p">(</span><span class="s">&quot;孙悟空&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">30</span><span class="p">);</span>
<a id="__codelineno-5-60" name="__codelineno-5-60" href="#__codelineno-5-60"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p2</span><span class="p">(</span><span class="s">&quot;韩信&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">20</span><span class="p">);</span>
<a id="__codelineno-5-61" name="__codelineno-5-61" href="#__codelineno-5-61"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p3</span><span class="p">(</span><span class="s">&quot;妲己&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">18</span><span class="p">);</span>
<a id="__codelineno-5-62" name="__codelineno-5-62" href="#__codelineno-5-62"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p4</span><span class="p">(</span><span class="s">&quot;王昭君&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">15</span><span class="p">);</span>
<a id="__codelineno-5-63" name="__codelineno-5-63" href="#__codelineno-5-63"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p5</span><span class="p">(</span><span class="s">&quot;赵云&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">24</span><span class="p">);</span>
<a id="__codelineno-5-64" name="__codelineno-5-64" href="#__codelineno-5-64"></a>
<a id="__codelineno-5-65" name="__codelineno-5-65" href="#__codelineno-5-65"></a><span class="w">    </span><span class="c1">//插入数据</span>
<a id="__codelineno-5-66" name="__codelineno-5-66" href="#__codelineno-5-66"></a><span class="w">    </span><span class="n">pArray</span><span class="p">.</span><span class="n">Push_back</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
<a id="__codelineno-5-67" name="__codelineno-5-67" href="#__codelineno-5-67"></a><span class="w">    </span><span class="n">pArray</span><span class="p">.</span><span class="n">Push_back</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
<a id="__codelineno-5-68" name="__codelineno-5-68" href="#__codelineno-5-68"></a><span class="w">    </span><span class="n">pArray</span><span class="p">.</span><span class="n">Push_back</span><span class="p">(</span><span class="n">p3</span><span class="p">);</span>
<a id="__codelineno-5-69" name="__codelineno-5-69" href="#__codelineno-5-69"></a><span class="w">    </span><span class="n">pArray</span><span class="p">.</span><span class="n">Push_back</span><span class="p">(</span><span class="n">p4</span><span class="p">);</span>
<a id="__codelineno-5-70" name="__codelineno-5-70" href="#__codelineno-5-70"></a><span class="w">    </span><span class="n">pArray</span><span class="p">.</span><span class="n">Push_back</span><span class="p">(</span><span class="n">p5</span><span class="p">);</span>
<a id="__codelineno-5-71" name="__codelineno-5-71" href="#__codelineno-5-71"></a>
<a id="__codelineno-5-72" name="__codelineno-5-72" href="#__codelineno-5-72"></a><span class="w">    </span><span class="n">printPersonArray</span><span class="p">(</span><span class="n">pArray</span><span class="p">);</span>
<a id="__codelineno-5-73" name="__codelineno-5-73" href="#__codelineno-5-73"></a>
<a id="__codelineno-5-74" name="__codelineno-5-74" href="#__codelineno-5-74"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;pArray的大小：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pArray</span><span class="p">.</span><span class="n">getSize</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-75" name="__codelineno-5-75" href="#__codelineno-5-75"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;pArray的容量：&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">pArray</span><span class="p">.</span><span class="n">getCapacity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-76" name="__codelineno-5-76" href="#__codelineno-5-76"></a>
<a id="__codelineno-5-77" name="__codelineno-5-77" href="#__codelineno-5-77"></a><span class="p">}</span>
<a id="__codelineno-5-78" name="__codelineno-5-78" href="#__codelineno-5-78"></a>
<a id="__codelineno-5-79" name="__codelineno-5-79" href="#__codelineno-5-79"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-80" name="__codelineno-5-80" href="#__codelineno-5-80"></a>
<a id="__codelineno-5-81" name="__codelineno-5-81" href="#__codelineno-5-81"></a><span class="w">    </span><span class="c1">//test01();</span>
<a id="__codelineno-5-82" name="__codelineno-5-82" href="#__codelineno-5-82"></a>
<a id="__codelineno-5-83" name="__codelineno-5-83" href="#__codelineno-5-83"></a><span class="w">    </span><span class="n">test02</span><span class="p">();</span>
<a id="__codelineno-5-84" name="__codelineno-5-84" href="#__codelineno-5-84"></a>
<a id="__codelineno-5-85" name="__codelineno-5-85" href="#__codelineno-5-85"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-5-86" name="__codelineno-5-86" href="#__codelineno-5-86"></a>
<a id="__codelineno-5-87" name="__codelineno-5-87" href="#__codelineno-5-87"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-5-88" name="__codelineno-5-88" href="#__codelineno-5-88"></a><span class="p">}</span>
<a id="__codelineno-5-89" name="__codelineno-5-89" href="#__codelineno-5-89"></a><span class="err">```</span><span class="w"> </span><span class="o">**</span><span class="n">总结</span><span class="err">：</span><span class="o">**</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">能够利用所学知识点实现通用的数组</span><span class="err">。</span>
<a id="__codelineno-5-90" name="__codelineno-5-90" href="#__codelineno-5-90"></a>
<a id="__codelineno-5-91" name="__codelineno-5-91" href="#__codelineno-5-91"></a><span class="o">---</span>
<a id="__codelineno-5-92" name="__codelineno-5-92" href="#__codelineno-5-92"></a>
<a id="__codelineno-5-93" name="__codelineno-5-93" href="#__codelineno-5-93"></a>
<a id="__codelineno-5-94" name="__codelineno-5-94" href="#__codelineno-5-94"></a>
<a id="__codelineno-5-95" name="__codelineno-5-95" href="#__codelineno-5-95"></a><span class="cp">## 2 STL初识</span>
<a id="__codelineno-5-96" name="__codelineno-5-96" href="#__codelineno-5-96"></a>
<a id="__codelineno-5-97" name="__codelineno-5-97" href="#__codelineno-5-97"></a><span class="cp">### 2.1 STL的诞生</span>
<a id="__codelineno-5-98" name="__codelineno-5-98" href="#__codelineno-5-98"></a>
<a id="__codelineno-5-99" name="__codelineno-5-99" href="#__codelineno-5-99"></a><span class="o">*</span><span class="w"> </span><span class="n">长久以来</span><span class="err">，</span><span class="n">软件界一直希望建立一种可重复利用的东西</span>
<a id="__codelineno-5-100" name="__codelineno-5-100" href="#__codelineno-5-100"></a><span class="o">*</span><span class="w"> </span><span class="n">C</span><span class="o">++</span><span class="n">的</span><span class="w"> </span><span class="o">**</span><span class="n">面向对象</span><span class="o">**</span><span class="w"> </span><span class="n">和</span><span class="w"> </span><span class="o">**</span><span class="n">泛型编程</span><span class="o">**</span><span class="w"> </span><span class="n">思想</span><span class="err">，</span><span class="n">目的就是</span><span class="w"> </span><span class="o">**</span><span class="n">复用性的提升</span><span class="o">**</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">面向对象</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">封装</span><span class="err">：</span><span class="n">把一些属性或行为比较相似的事物抽象出来作为一个整体</span><span class="err">，</span><span class="n">封装成类</span><span class="err">。</span>
<a id="__codelineno-5-101" name="__codelineno-5-101" href="#__codelineno-5-101"></a><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">面向对象</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">继承</span><span class="err">：</span><span class="n">子类继承父类的属性和行为</span><span class="err">。</span>
<a id="__codelineno-5-102" name="__codelineno-5-102" href="#__codelineno-5-102"></a><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">面向对象</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">多态</span><span class="err">：</span><span class="n">一个函数名称有多个接口</span><span class="err">（</span><span class="n">根据传参</span><span class="err">）。</span>
<a id="__codelineno-5-103" name="__codelineno-5-103" href="#__codelineno-5-103"></a><span class="w">  </span><span class="o">-</span><span class="w"> </span><span class="n">泛型编程</span><span class="err">：</span><span class="n">使用模板</span><span class="err">，</span><span class="n">可以对应多种数据类型传参</span><span class="err">。</span>
<a id="__codelineno-5-104" name="__codelineno-5-104" href="#__codelineno-5-104"></a><span class="o">*</span><span class="w"> </span><span class="n">大多情况下</span><span class="err">，</span><span class="n">数据结构和算法都未能有一套标准</span><span class="p">,</span><span class="n">导致被迫从事大量重复工作</span>
<a id="__codelineno-5-105" name="__codelineno-5-105" href="#__codelineno-5-105"></a><span class="o">*</span><span class="w"> </span><span class="n">为了建立数据结构和算法的一套标准</span><span class="p">,</span><span class="n">诞生了</span><span class="w"> </span><span class="o">**</span><span class="n">STL</span><span class="o">**</span><span class="w"> </span><span class="err">###</span><span class="w"> </span><span class="mf">2.2</span><span class="w"> </span><span class="n">STL基本概念</span>
<a id="__codelineno-5-106" name="__codelineno-5-106" href="#__codelineno-5-106"></a>
<a id="__codelineno-5-107" name="__codelineno-5-107" href="#__codelineno-5-107"></a><span class="o">*</span><span class="w"> </span><span class="n">STL</span><span class="p">(</span><span class="n">Standard</span><span class="w"> </span><span class="n">Template</span><span class="w"> </span><span class="n">Library</span><span class="p">,</span><span class="w"> </span><span class="o">**</span><span class="n">标准模板库</span><span class="o">**</span><span class="w"> </span><span class="p">)</span>
<a id="__codelineno-5-108" name="__codelineno-5-108" href="#__codelineno-5-108"></a><span class="o">*</span><span class="w"> </span><span class="n">STL</span><span class="w"> </span><span class="n">从广义上分为</span><span class="o">:</span><span class="w"> </span><span class="o">**</span><span class="n">容器</span><span class="p">(</span><span class="n">container</span><span class="p">)</span><span class="err">；</span><span class="w"> </span><span class="n">算法</span><span class="p">(</span><span class="n">algorithm</span><span class="p">)</span><span class="err">；</span><span class="w"> </span><span class="n">迭代器</span><span class="p">(</span><span class="n">iterator</span><span class="p">)</span><span class="o">**</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="o">**</span><span class="n">容器</span><span class="o">**</span><span class="w"> </span><span class="n">和</span><span class="w"> </span><span class="o">**</span><span class="n">算法</span><span class="o">**</span><span class="w"> </span><span class="n">之间通过</span><span class="w"> </span><span class="o">**</span><span class="n">迭代器</span><span class="o">**</span><span class="w"> </span><span class="n">进行无缝连接</span><span class="err">。</span>
<a id="__codelineno-5-109" name="__codelineno-5-109" href="#__codelineno-5-109"></a><span class="o">*</span><span class="w"> </span><span class="n">STL</span><span class="w"> </span><span class="n">几乎所有的代码都采用了模板类或者模板函数</span>
<a id="__codelineno-5-110" name="__codelineno-5-110" href="#__codelineno-5-110"></a>
<a id="__codelineno-5-111" name="__codelineno-5-111" href="#__codelineno-5-111"></a><span class="cp">### 2.3 STL六大组件</span>
<a id="__codelineno-5-112" name="__codelineno-5-112" href="#__codelineno-5-112"></a>
<a id="__codelineno-5-113" name="__codelineno-5-113" href="#__codelineno-5-113"></a><span class="n">STL大体分为六大组件</span><span class="err">，</span><span class="n">分别是</span><span class="o">:</span><span class="w"> </span><span class="o">**</span><span class="n">容器</span><span class="err">、</span><span class="n">算法</span><span class="err">、</span><span class="n">迭代器</span><span class="err">、</span><span class="n">仿函数</span><span class="err">、</span><span class="n">适配器</span><span class="err">（</span><span class="n">配接器</span><span class="err">）、</span><span class="n">空间配置器</span><span class="o">**</span><span class="w"> </span><span class="mf">1.</span><span class="w"> </span><span class="n">容器</span><span class="err">：</span><span class="n">各种数据结构</span><span class="err">，</span><span class="n">如vector</span><span class="err">、</span><span class="n">list</span><span class="err">、</span><span class="n">deque</span><span class="err">、</span><span class="n">set</span><span class="err">、</span><span class="n">map等</span><span class="p">,</span><span class="n">用来存放数据</span><span class="err">。</span>
<a id="__codelineno-5-114" name="__codelineno-5-114" href="#__codelineno-5-114"></a><span class="mf">2.</span><span class="w"> </span><span class="n">算法</span><span class="err">：</span><span class="n">各种常用的算法</span><span class="err">，</span><span class="n">如sort</span><span class="err">、</span><span class="n">find</span><span class="err">、</span><span class="n">copy</span><span class="err">、</span><span class="n">for_each等</span>
<a id="__codelineno-5-115" name="__codelineno-5-115" href="#__codelineno-5-115"></a><span class="mf">3.</span><span class="w"> </span><span class="n">迭代器</span><span class="err">：</span><span class="n">扮演了容器与算法之间的胶合剂</span><span class="err">。</span>
<a id="__codelineno-5-116" name="__codelineno-5-116" href="#__codelineno-5-116"></a><span class="mf">4.</span><span class="w"> </span><span class="n">仿函数</span><span class="err">：</span><span class="n">行为类似函数</span><span class="err">，</span><span class="n">可作为算法的某种策略</span><span class="err">。</span>
<a id="__codelineno-5-117" name="__codelineno-5-117" href="#__codelineno-5-117"></a><span class="mf">5.</span><span class="w"> </span><span class="n">适配器</span><span class="err">：</span><span class="n">一种用来修饰容器或者仿函数或迭代器接口的东西</span><span class="err">。</span>
<a id="__codelineno-5-118" name="__codelineno-5-118" href="#__codelineno-5-118"></a><span class="mf">6.</span><span class="w"> </span><span class="n">空间配置器</span><span class="err">：</span><span class="n">负责空间的配置与管理</span><span class="err">。</span>
<a id="__codelineno-5-119" name="__codelineno-5-119" href="#__codelineno-5-119"></a>
<a id="__codelineno-5-120" name="__codelineno-5-120" href="#__codelineno-5-120"></a><span class="cp">### 2.4  STL中容器、算法、迭代器 **容器：** 置物之所也</span>
<a id="__codelineno-5-121" name="__codelineno-5-121" href="#__codelineno-5-121"></a>
<a id="__codelineno-5-122" name="__codelineno-5-122" href="#__codelineno-5-122"></a><span class="o">-</span><span class="w"> </span><span class="n">STL</span><span class="w"> </span><span class="o">**</span><span class="n">容器</span><span class="o">**</span><span class="w"> </span><span class="n">就是将运用</span><span class="w"> </span><span class="o">**</span><span class="n">最广泛的一些数据结构</span><span class="o">**</span><span class="w"> </span><span class="n">实现出来</span>
<a id="__codelineno-5-123" name="__codelineno-5-123" href="#__codelineno-5-123"></a>
<a id="__codelineno-5-124" name="__codelineno-5-124" href="#__codelineno-5-124"></a><span class="o">-</span><span class="w"> </span><span class="n">常用的数据结构</span><span class="err">：</span><span class="n">数组</span><span class="p">,</span><span class="w"> </span><span class="n">链表</span><span class="p">,</span><span class="n">树</span><span class="p">,</span><span class="w"> </span><span class="n">栈</span><span class="p">,</span><span class="w"> </span><span class="n">队列</span><span class="p">,</span><span class="w"> </span><span class="n">集合</span><span class="p">,</span><span class="w"> </span><span class="n">映射表</span><span class="w"> </span><span class="n">等</span>
<a id="__codelineno-5-125" name="__codelineno-5-125" href="#__codelineno-5-125"></a>
<a id="__codelineno-5-126" name="__codelineno-5-126" href="#__codelineno-5-126"></a><span class="n">这些容器分为</span><span class="w"> </span><span class="o">**</span><span class="n">序列式容器</span><span class="o">**</span><span class="w"> </span><span class="n">和</span><span class="w"> </span><span class="o">**</span><span class="n">关联式容器</span><span class="o">**</span><span class="w"> </span><span class="n">两种</span><span class="o">:</span>
<a id="__codelineno-5-127" name="__codelineno-5-127" href="#__codelineno-5-127"></a>
<a id="__codelineno-5-128" name="__codelineno-5-128" href="#__codelineno-5-128"></a><span class="o">-</span><span class="w">  </span><span class="o">**</span><span class="n">序列式容器</span><span class="o">**</span><span class="w"> </span><span class="o">:</span><span class="n">强调值的排序</span><span class="err">，</span><span class="n">序列式容器中的每个元素均有固定的位置</span><span class="err">。</span>
<a id="__codelineno-5-129" name="__codelineno-5-129" href="#__codelineno-5-129"></a><span class="o">-</span><span class="w"> </span><span class="err">​</span><span class="w">  </span><span class="o">**</span><span class="n">关联式容器</span><span class="o">**</span><span class="w"> </span><span class="o">:</span><span class="n">二叉树结构</span><span class="err">，</span><span class="n">各元素之间没有严格的物理上的顺序关系</span><span class="w"> </span><span class="o">**</span><span class="n">算法</span><span class="err">：</span><span class="o">**</span><span class="w"> </span><span class="n">问题之解法也</span>
<a id="__codelineno-5-130" name="__codelineno-5-130" href="#__codelineno-5-130"></a>
<a id="__codelineno-5-131" name="__codelineno-5-131" href="#__codelineno-5-131"></a><span class="o">-</span><span class="w"> </span><span class="n">有限的步骤</span><span class="err">，</span><span class="n">解决逻辑或数学上的问题</span><span class="err">，</span><span class="n">这一门学科我们叫做算法</span><span class="p">(</span><span class="n">Algorithms</span><span class="p">)</span>
<a id="__codelineno-5-132" name="__codelineno-5-132" href="#__codelineno-5-132"></a>
<a id="__codelineno-5-133" name="__codelineno-5-133" href="#__codelineno-5-133"></a><span class="nl">算法分为</span><span class="p">:</span><span class="w"> </span><span class="o">**</span><span class="n">质变算法</span><span class="o">**</span><span class="w"> </span><span class="n">和</span><span class="w"> </span><span class="o">**</span><span class="n">非质变算法</span><span class="o">**</span><span class="w"> </span><span class="err">。</span>
<a id="__codelineno-5-134" name="__codelineno-5-134" href="#__codelineno-5-134"></a>
<a id="__codelineno-5-135" name="__codelineno-5-135" href="#__codelineno-5-135"></a><span class="o">-</span><span class="w"> </span><span class="n">质变算法</span><span class="err">：</span><span class="n">是指运算过程中会更改区间内的元素的内容</span><span class="err">。</span><span class="n">例如拷贝</span><span class="err">，</span><span class="n">替换</span><span class="err">，</span><span class="n">删除等等</span>
<a id="__codelineno-5-136" name="__codelineno-5-136" href="#__codelineno-5-136"></a>
<a id="__codelineno-5-137" name="__codelineno-5-137" href="#__codelineno-5-137"></a><span class="o">-</span><span class="w"> </span><span class="n">非质变算法</span><span class="err">：</span><span class="n">是指运算过程中不会更改区间内的元素内容</span><span class="err">，</span><span class="n">例如查找</span><span class="err">、</span><span class="n">计数</span><span class="err">、</span><span class="n">遍历</span><span class="err">、</span><span class="n">寻找极值等等</span><span class="w"> </span><span class="o">**</span><span class="n">迭代器</span><span class="err">：</span><span class="o">**</span><span class="w"> </span><span class="n">容器和算法之间粘合剂</span>
<a id="__codelineno-5-138" name="__codelineno-5-138" href="#__codelineno-5-138"></a>
<a id="__codelineno-5-139" name="__codelineno-5-139" href="#__codelineno-5-139"></a><span class="o">-</span><span class="w"> </span><span class="n">提供一种方法</span><span class="err">，</span><span class="n">使之能够依序寻访某个容器所含的各个元素</span><span class="err">，</span><span class="n">而又无需暴露该容器的内部表示方式</span><span class="err">。</span>
<a id="__codelineno-5-140" name="__codelineno-5-140" href="#__codelineno-5-140"></a>
<a id="__codelineno-5-141" name="__codelineno-5-141" href="#__codelineno-5-141"></a><span class="o">-</span><span class="w"> </span><span class="n">每个容器都有自己专属的迭代器</span>
<a id="__codelineno-5-142" name="__codelineno-5-142" href="#__codelineno-5-142"></a>
<a id="__codelineno-5-143" name="__codelineno-5-143" href="#__codelineno-5-143"></a><span class="o">-</span><span class="w"> </span><span class="n">迭代器使用非常类似于指针</span><span class="err">，</span><span class="n">初学阶段我们可以先理解迭代器为指针</span>
<a id="__codelineno-5-144" name="__codelineno-5-144" href="#__codelineno-5-144"></a>
<a id="__codelineno-5-145" name="__codelineno-5-145" href="#__codelineno-5-145"></a><span class="n">迭代器种类</span><span class="err">：</span>
<a id="__codelineno-5-146" name="__codelineno-5-146" href="#__codelineno-5-146"></a>
<a id="__codelineno-5-147" name="__codelineno-5-147" href="#__codelineno-5-147"></a><span class="o">|</span><span class="w"> </span><span class="n">种类</span><span class="w">           </span><span class="o">|</span><span class="w"> </span><span class="n">功能</span><span class="w">                                                     </span><span class="o">|</span><span class="w"> </span><span class="n">支持运算</span><span class="w">                                </span><span class="o">|</span>
<a id="__codelineno-5-148" name="__codelineno-5-148" href="#__codelineno-5-148"></a><span class="o">|</span><span class="w"> </span><span class="o">--------------</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">--------------------------------------------------------</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="o">---------------------------------------</span><span class="w"> </span><span class="o">|</span>
<a id="__codelineno-5-149" name="__codelineno-5-149" href="#__codelineno-5-149"></a><span class="o">|</span><span class="w"> </span><span class="n">输入迭代器</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">对数据的只读访问</span><span class="w">                                         </span><span class="o">|</span><span class="w"> </span><span class="n">只读</span><span class="err">，</span><span class="n">支持</span><span class="o">++</span><span class="err">、</span><span class="o">==</span><span class="err">、！</span><span class="o">=</span><span class="w">                   </span><span class="o">|</span>
<a id="__codelineno-5-150" name="__codelineno-5-150" href="#__codelineno-5-150"></a><span class="o">|</span><span class="w"> </span><span class="n">输出迭代器</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">对数据的只写访问</span><span class="w">                                         </span><span class="o">|</span><span class="w"> </span><span class="n">只写</span><span class="err">，</span><span class="n">支持</span><span class="o">++</span><span class="w">                            </span><span class="o">|</span>
<a id="__codelineno-5-151" name="__codelineno-5-151" href="#__codelineno-5-151"></a><span class="o">|</span><span class="w"> </span><span class="n">前向迭代器</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">读写操作</span><span class="err">，</span><span class="n">并能向前推进迭代器</span><span class="w">                             </span><span class="o">|</span><span class="w"> </span><span class="n">读写</span><span class="err">，</span><span class="n">支持</span><span class="o">++</span><span class="err">、</span><span class="o">==</span><span class="err">、！</span><span class="o">=</span><span class="w">                   </span><span class="o">|</span>
<a id="__codelineno-5-152" name="__codelineno-5-152" href="#__codelineno-5-152"></a><span class="o">|</span><span class="w"> </span><span class="n">双向迭代器</span><span class="w">     </span><span class="o">|</span><span class="w"> </span><span class="n">读写操作</span><span class="err">，</span><span class="n">并能向前和向后操作</span><span class="w">                             </span><span class="o">|</span><span class="w"> </span><span class="n">读写</span><span class="err">，</span><span class="n">支持</span><span class="o">++</span><span class="err">、</span><span class="o">--</span><span class="err">，</span><span class="w">                      </span><span class="o">|</span>
<a id="__codelineno-5-153" name="__codelineno-5-153" href="#__codelineno-5-153"></a><span class="o">|</span><span class="w"> </span><span class="n">随机访问迭代器</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">读写操作</span><span class="err">，</span><span class="n">可以以跳跃的方式访问任意数据</span><span class="err">，</span><span class="n">功能最强的迭代器</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">读写</span><span class="err">，</span><span class="n">支持</span><span class="o">++</span><span class="err">、</span><span class="o">--</span><span class="err">、</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="err">、</span><span class="o">-</span><span class="n">n</span><span class="err">、</span><span class="o">&lt;</span><span class="err">、</span><span class="o">&lt;=</span><span class="err">、</span><span class="o">&gt;</span><span class="err">、</span><span class="o">&gt;=</span><span class="w"> </span><span class="o">|</span>
<a id="__codelineno-5-154" name="__codelineno-5-154" href="#__codelineno-5-154"></a>
<a id="__codelineno-5-155" name="__codelineno-5-155" href="#__codelineno-5-155"></a><span class="n">常用的容器中迭代器种类为双向迭代器</span><span class="err">，</span><span class="n">和随机访问迭代器</span><span class="err">。</span>
<a id="__codelineno-5-156" name="__codelineno-5-156" href="#__codelineno-5-156"></a>
<a id="__codelineno-5-157" name="__codelineno-5-157" href="#__codelineno-5-157"></a><span class="cp">### 2.5 容器算法迭代器初识</span>
<a id="__codelineno-5-158" name="__codelineno-5-158" href="#__codelineno-5-158"></a>
<a id="__codelineno-5-159" name="__codelineno-5-159" href="#__codelineno-5-159"></a><span class="n">了解STL中容器</span><span class="err">、</span><span class="n">算法</span><span class="err">、</span><span class="n">迭代器概念之后</span><span class="err">，</span><span class="n">我们利用代码感受STL的魅力</span><span class="err">。</span>
<a id="__codelineno-5-160" name="__codelineno-5-160" href="#__codelineno-5-160"></a>
<a id="__codelineno-5-161" name="__codelineno-5-161" href="#__codelineno-5-161"></a><span class="n">STL中最常用的容器为Vector</span><span class="err">，</span><span class="n">可以理解为数组</span><span class="err">，</span><span class="n">下面我们将学习如何向这个容器中插入数据</span><span class="err">、</span><span class="n">并遍历这个容器</span><span class="err">。</span>
<a id="__codelineno-5-162" name="__codelineno-5-162" href="#__codelineno-5-162"></a>
<a id="__codelineno-5-163" name="__codelineno-5-163" href="#__codelineno-5-163"></a><span class="cp">#### 2.5.1 vector存放内置数据类型</span>
<a id="__codelineno-5-164" name="__codelineno-5-164" href="#__codelineno-5-164"></a>
<a id="__codelineno-5-165" name="__codelineno-5-165" href="#__codelineno-5-165"></a>
<a id="__codelineno-5-166" name="__codelineno-5-166" href="#__codelineno-5-166"></a>
<a id="__codelineno-5-167" name="__codelineno-5-167" href="#__codelineno-5-167"></a><span class="n">容器</span><span class="err">：</span><span class="w">     </span><span class="err">`</span><span class="n">vector</span><span class="err">`</span>
<a id="__codelineno-5-168" name="__codelineno-5-168" href="#__codelineno-5-168"></a>
<a id="__codelineno-5-169" name="__codelineno-5-169" href="#__codelineno-5-169"></a><span class="n">算法</span><span class="err">：</span><span class="w">     </span><span class="err">`</span><span class="n">for_each</span><span class="err">`</span>
<a id="__codelineno-5-170" name="__codelineno-5-170" href="#__codelineno-5-170"></a>
<a id="__codelineno-5-171" name="__codelineno-5-171" href="#__codelineno-5-171"></a><span class="n">迭代器</span><span class="err">：</span><span class="w"> </span><span class="err">`</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="err">`</span>
<a id="__codelineno-5-172" name="__codelineno-5-172" href="#__codelineno-5-172"></a>
<a id="__codelineno-5-173" name="__codelineno-5-173" href="#__codelineno-5-173"></a><span class="w"> </span><span class="o">**</span><span class="n">示例</span><span class="err">：</span><span class="o">**</span><span class="w"> </span><span class="err">```</span><span class="n">C</span><span class="o">++</span>
<a id="__codelineno-5-174" name="__codelineno-5-174" href="#__codelineno-5-174"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<a id="__codelineno-5-175" name="__codelineno-5-175" href="#__codelineno-5-175"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;algorithm&gt;</span>
<a id="__codelineno-5-176" name="__codelineno-5-176" href="#__codelineno-5-176"></a>
<a id="__codelineno-5-177" name="__codelineno-5-177" href="#__codelineno-5-177"></a><span class="kt">void</span><span class="w"> </span><span class="n">MyPrint</span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">val</span><span class="p">)</span>
<a id="__codelineno-5-178" name="__codelineno-5-178" href="#__codelineno-5-178"></a><span class="p">{</span>
<a id="__codelineno-5-179" name="__codelineno-5-179" href="#__codelineno-5-179"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">val</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-180" name="__codelineno-5-180" href="#__codelineno-5-180"></a><span class="p">}</span>
<a id="__codelineno-5-181" name="__codelineno-5-181" href="#__codelineno-5-181"></a>
<a id="__codelineno-5-182" name="__codelineno-5-182" href="#__codelineno-5-182"></a><span class="kt">void</span><span class="w"> </span><span class="n">test01</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-183" name="__codelineno-5-183" href="#__codelineno-5-183"></a>
<a id="__codelineno-5-184" name="__codelineno-5-184" href="#__codelineno-5-184"></a><span class="w">    </span><span class="c1">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span>
<a id="__codelineno-5-185" name="__codelineno-5-185" href="#__codelineno-5-185"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v</span><span class="p">;</span>
<a id="__codelineno-5-186" name="__codelineno-5-186" href="#__codelineno-5-186"></a><span class="w">    </span><span class="c1">//向容器中放数据</span>
<a id="__codelineno-5-187" name="__codelineno-5-187" href="#__codelineno-5-187"></a><span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-5-188" name="__codelineno-5-188" href="#__codelineno-5-188"></a><span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<a id="__codelineno-5-189" name="__codelineno-5-189" href="#__codelineno-5-189"></a><span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
<a id="__codelineno-5-190" name="__codelineno-5-190" href="#__codelineno-5-190"></a><span class="w">    </span><span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
<a id="__codelineno-5-191" name="__codelineno-5-191" href="#__codelineno-5-191"></a>
<a id="__codelineno-5-192" name="__codelineno-5-192" href="#__codelineno-5-192"></a><span class="w">    </span><span class="c1">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span>
<a id="__codelineno-5-193" name="__codelineno-5-193" href="#__codelineno-5-193"></a><span class="w">    </span><span class="c1">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span>
<a id="__codelineno-5-194" name="__codelineno-5-194" href="#__codelineno-5-194"></a><span class="w">    </span><span class="c1">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span>
<a id="__codelineno-5-195" name="__codelineno-5-195" href="#__codelineno-5-195"></a><span class="w">    </span><span class="c1">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span>
<a id="__codelineno-5-196" name="__codelineno-5-196" href="#__codelineno-5-196"></a>
<a id="__codelineno-5-197" name="__codelineno-5-197" href="#__codelineno-5-197"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">pBegin</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<a id="__codelineno-5-198" name="__codelineno-5-198" href="#__codelineno-5-198"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">pEnd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
<a id="__codelineno-5-199" name="__codelineno-5-199" href="#__codelineno-5-199"></a>
<a id="__codelineno-5-200" name="__codelineno-5-200" href="#__codelineno-5-200"></a><span class="w">    </span><span class="c1">//第一种遍历方式：</span>
<a id="__codelineno-5-201" name="__codelineno-5-201" href="#__codelineno-5-201"></a><span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">pBegin</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">pEnd</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-202" name="__codelineno-5-202" href="#__codelineno-5-202"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">pBegin</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-203" name="__codelineno-5-203" href="#__codelineno-5-203"></a><span class="w">        </span><span class="n">pBegin</span><span class="o">++</span><span class="p">;</span>
<a id="__codelineno-5-204" name="__codelineno-5-204" href="#__codelineno-5-204"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-5-205" name="__codelineno-5-205" href="#__codelineno-5-205"></a>
<a id="__codelineno-5-206" name="__codelineno-5-206" href="#__codelineno-5-206"></a>
<a id="__codelineno-5-207" name="__codelineno-5-207" href="#__codelineno-5-207"></a><span class="w">    </span><span class="c1">//第二种遍历方式：</span>
<a id="__codelineno-5-208" name="__codelineno-5-208" href="#__codelineno-5-208"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-209" name="__codelineno-5-209" href="#__codelineno-5-209"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-210" name="__codelineno-5-210" href="#__codelineno-5-210"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-5-211" name="__codelineno-5-211" href="#__codelineno-5-211"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-5-212" name="__codelineno-5-212" href="#__codelineno-5-212"></a>
<a id="__codelineno-5-213" name="__codelineno-5-213" href="#__codelineno-5-213"></a><span class="w">    </span><span class="c1">//第三种遍历方式：</span>
<a id="__codelineno-5-214" name="__codelineno-5-214" href="#__codelineno-5-214"></a><span class="w">    </span><span class="c1">//使用STL提供标准遍历算法  头文件 algorithm</span>
<a id="__codelineno-5-215" name="__codelineno-5-215" href="#__codelineno-5-215"></a><span class="w">    </span><span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="w"> </span><span class="n">MyPrint</span><span class="p">);</span>
<a id="__codelineno-5-216" name="__codelineno-5-216" href="#__codelineno-5-216"></a><span class="p">}</span>
<a id="__codelineno-5-217" name="__codelineno-5-217" href="#__codelineno-5-217"></a>
<a id="__codelineno-5-218" name="__codelineno-5-218" href="#__codelineno-5-218"></a><span class="kt">int</span><span class="w"> </span><span class="n">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-5-219" name="__codelineno-5-219" href="#__codelineno-5-219"></a>
<a id="__codelineno-5-220" name="__codelineno-5-220" href="#__codelineno-5-220"></a><span class="w">    </span><span class="n">test01</span><span class="p">();</span>
<a id="__codelineno-5-221" name="__codelineno-5-221" href="#__codelineno-5-221"></a>
<a id="__codelineno-5-222" name="__codelineno-5-222" href="#__codelineno-5-222"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-5-223" name="__codelineno-5-223" href="#__codelineno-5-223"></a>
<a id="__codelineno-5-224" name="__codelineno-5-224" href="#__codelineno-5-224"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-5-225" name="__codelineno-5-225" href="#__codelineno-5-225"></a><span class="p">}</span>
</code></pre></div>
<h4 id="252-vector">2.5.2 Vector存放自定义数据类型<a class="headerlink" href="#252-vector" title="Permanent link">&para;</a></h4>
<p>学习目标：vector中存放自定义数据类型，并打印输出</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_5">include <vector><a class="headerlink" href="#include_5" title="Permanent link">&para;</a></h1>
<h1 id="include_6">include <string><a class="headerlink" href="#include_6" title="Permanent link">&para;</a></h1>
<p>//自定义数据类型
class Person {
public:
    Person(string name, int age) {
        mName = name;
        mAge = age;
    }
public:
    string mName;
    int mAge;
};
//存放对象
void test01() {</p>
<div class="highlight"><pre><span></span><code>vector&lt;Person&gt; v;

//创建数据
Person p1(&quot;aaa&quot;, 10);
Person p2(&quot;bbb&quot;, 20);
Person p3(&quot;ccc&quot;, 30);
Person p4(&quot;ddd&quot;, 40);
Person p5(&quot;eee&quot;, 50);

v.push_back(p1);
v.push_back(p2);
v.push_back(p3);
v.push_back(p4);
v.push_back(p5);

for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) {
    cout &lt;&lt; &quot;Name:&quot; &lt;&lt; (*it).mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it).mAge &lt;&lt; endl;

}
</code></pre></div>
<p>}</p>
<p>//放对象指针
void test02() {</p>
<div class="highlight"><pre><span></span><code>vector&lt;Person*&gt; v;

//创建数据
Person p1(&quot;aaa&quot;, 10);
Person p2(&quot;bbb&quot;, 20);
Person p3(&quot;ccc&quot;, 30);
Person p4(&quot;ddd&quot;, 40);
Person p5(&quot;eee&quot;, 50);

v.push_back(&amp;p1);
v.push_back(&amp;p2);
v.push_back(&amp;p3);
v.push_back(&amp;p4);
v.push_back(&amp;p5);

for (vector&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) {
    Person * p = (*it);
    cout &lt;&lt; &quot;Name:&quot; &lt;&lt; p-&gt;mName &lt;&lt; &quot; Age:&quot; &lt;&lt; (*it)-&gt;mAge &lt;&lt; endl;
}
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```


</p>
<h4 id="253-vector">2.5.3 Vector容器嵌套容器<a class="headerlink" href="#253-vector" title="Permanent link">&para;</a></h4>
<p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出

 <strong>示例：</strong> ```C++</p>
<h1 id="include_7">include <vector><a class="headerlink" href="#include_7" title="Permanent link">&para;</a></h1>
<p>//容器嵌套容器
void test01() {

    vector&lt; vector<int> &gt;  v;

    vector<int> v1;
    vector<int> v2;
    vector<int> v3;
    vector<int> v4;

    for (int i = 0; i &lt; 4; i++) {
        v1.push_back(i + 1);
        v2.push_back(i + 2);
        v3.push_back(i + 3);
        v4.push_back(i + 4);
    }

    //将容器元素插入到vector v中
    v.push_back(v1);
    v.push_back(v2);
    v.push_back(v3);
    v.push_back(v4);


    for (vector<vector\<int>>::iterator it = v.begin(); it != v.end(); it++) {

        for (vector<int>::iterator vit = (*it).begin(); vit != (*it).end(); vit++) {
            cout &lt;&lt; *vit &lt;&lt; " ";
        }
        cout &lt;&lt; endl;
    }

}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<h2 id="3-stl-">3 STL- 常用容器<a class="headerlink" href="#3-stl-" title="Permanent link">&para;</a></h2>
<h3 id="31-string">3.1 string容器<a class="headerlink" href="#31-string" title="Permanent link">&para;</a></h3>
<h4 id="311-string-stringcstring">3.1.1 string基本概念 <strong>本质：</strong> * string是C++风格的字符串，而string本质上是一个类<a class="headerlink" href="#311-string-stringcstring" title="Permanent link">&para;</a></h4>
<p><strong>string和char * 区别：</strong></p>
<ul>
<li>char * 是一个指针</li>
<li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。 <strong>特点：</strong> string 类内部封装了很多成员方法</li>
</ul>
<p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p>
<p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p>
<h4 id="312-string">3.1.2 string构造函数<a class="headerlink" href="#312-string" title="Permanent link">&para;</a></h4>
<p>构造函数原型：</p>
<ul>
<li><code>string();</code>                       //创建一个空的字符串 例如: string str;
  <code>string(const char* s);</code>          //使用字符串s初始化</li>
<li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li>
<li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_8">include <string><a class="headerlink" href="#include_8" title="Permanent link">&para;</a></h1>
<p>//string构造
void test01()
{
    string s1; //创建空字符串，调用无参构造函数
    cout &lt;&lt; "str1 = " &lt;&lt; s1 &lt;&lt; endl;</p>
<div class="highlight"><pre><span></span><code>const char* str = &quot;hello world&quot;;
string s2(str); //把c_string转换成了string

cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; s2 &lt;&lt; endl;

string s3(s2); //调用拷贝构造函数
cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;

string s4(10, &#39;a&#39;);
cout &lt;&lt; &quot;str3 = &quot; &lt;&lt; s3 &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：string的多种构造方式没有可比性，灵活使用即可








</p>
<h4 id="313-string">3.1.3 string赋值操作<a class="headerlink" href="#313-string" title="Permanent link">&para;</a></h4>
<p>功能描述：

* 给string字符串进行赋值



赋值的函数原型：

* <code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串
* <code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串
* <code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串
* <code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串
* <code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串
* <code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串
* <code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串


 <strong>示例：</strong> <code>C++
//赋值
void test01()
{
    string str1;
    str1 = "hello world";
    cout &lt;&lt; "str1 = " &lt;&lt; str1 &lt;&lt; endl;

    string str2;
    str2 = str1;
    cout &lt;&lt; "str2 = " &lt;&lt; str2 &lt;&lt; endl;

    string str3;
    str3 = 'a';
    cout &lt;&lt; "str3 = " &lt;&lt; str3 &lt;&lt; endl;

    string str4;
    str4.assign("hello c++");
    cout &lt;&lt; "str4 = " &lt;&lt; str4 &lt;&lt; endl;

    string str5;
    str5.assign("hello c++",5);
    cout &lt;&lt; "str5 = " &lt;&lt; str5 &lt;&lt; endl;


    string str6;
    str6.assign(str5);
    cout &lt;&lt; "str6 = " &lt;&lt; str6 &lt;&lt; endl;

    string str7;
    str7.assign(5, 'x');
    cout &lt;&lt; "str7 = " &lt;&lt; str7 &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}</code></p>
<p>总结：</p>
<p>​   string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p>
<h4 id="314-string-string-operatorconst-char-str">3.1.4 string字符串拼接 <strong>功能描述：</strong> * 实现在字符串末尾拼接字符串 <strong>函数原型：</strong> * <code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符<a class="headerlink" href="#314-string-string-operatorconst-char-str" title="Permanent link">&para;</a></h4>
<ul>
<li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li>
<li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li>
<li><code>string&amp; append(const char *s);</code>                               //把字符串s连接到当前字符串结尾</li>
<li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li>
<li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li>
<li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li>
</ul>
<p><strong>示例：</strong> 
<div class="highlight"><pre><span></span><code><a id="__codelineno-8-1" name="__codelineno-8-1" href="#__codelineno-8-1"></a><span class="c1">//字符串拼接</span>
<a id="__codelineno-8-2" name="__codelineno-8-2" href="#__codelineno-8-2"></a><span class="kt">void</span><span class="w"> </span><span class="nf">test01</span><span class="p">()</span>
<a id="__codelineno-8-3" name="__codelineno-8-3" href="#__codelineno-8-3"></a><span class="p">{</span>
<a id="__codelineno-8-4" name="__codelineno-8-4" href="#__codelineno-8-4"></a><span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;我&quot;</span><span class="p">;</span>
<a id="__codelineno-8-5" name="__codelineno-8-5" href="#__codelineno-8-5"></a>
<a id="__codelineno-8-6" name="__codelineno-8-6" href="#__codelineno-8-6"></a><span class="w">    </span><span class="n">str1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="s">&quot;爱玩游戏&quot;</span><span class="p">;</span>
<a id="__codelineno-8-7" name="__codelineno-8-7" href="#__codelineno-8-7"></a>
<a id="__codelineno-8-8" name="__codelineno-8-8" href="#__codelineno-8-8"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;str1 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-8-9" name="__codelineno-8-9" href="#__codelineno-8-9"></a>
<a id="__codelineno-8-10" name="__codelineno-8-10" href="#__codelineno-8-10"></a><span class="w">    </span><span class="n">str1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="sc">&#39;:&#39;</span><span class="p">;</span>
<a id="__codelineno-8-11" name="__codelineno-8-11" href="#__codelineno-8-11"></a>
<a id="__codelineno-8-12" name="__codelineno-8-12" href="#__codelineno-8-12"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;str1 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-8-13" name="__codelineno-8-13" href="#__codelineno-8-13"></a>
<a id="__codelineno-8-14" name="__codelineno-8-14" href="#__codelineno-8-14"></a><span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">str2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;LOL DNF&quot;</span><span class="p">;</span>
<a id="__codelineno-8-15" name="__codelineno-8-15" href="#__codelineno-8-15"></a>
<a id="__codelineno-8-16" name="__codelineno-8-16" href="#__codelineno-8-16"></a><span class="w">    </span><span class="n">str1</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">str2</span><span class="p">;</span>
<a id="__codelineno-8-17" name="__codelineno-8-17" href="#__codelineno-8-17"></a>
<a id="__codelineno-8-18" name="__codelineno-8-18" href="#__codelineno-8-18"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;str1 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-8-19" name="__codelineno-8-19" href="#__codelineno-8-19"></a>
<a id="__codelineno-8-20" name="__codelineno-8-20" href="#__codelineno-8-20"></a><span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">str3</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&quot;I&quot;</span><span class="p">;</span>
<a id="__codelineno-8-21" name="__codelineno-8-21" href="#__codelineno-8-21"></a><span class="w">    </span><span class="n">str3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot; love &quot;</span><span class="p">);</span>
<a id="__codelineno-8-22" name="__codelineno-8-22" href="#__codelineno-8-22"></a><span class="w">    </span><span class="n">str3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="s">&quot;game abcde&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<a id="__codelineno-8-23" name="__codelineno-8-23" href="#__codelineno-8-23"></a><span class="w">    </span><span class="c1">//str3.append(str2);</span>
<a id="__codelineno-8-24" name="__codelineno-8-24" href="#__codelineno-8-24"></a><span class="w">    </span><span class="n">str3</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">str2</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">);</span><span class="w"> </span><span class="c1">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span>
<a id="__codelineno-8-25" name="__codelineno-8-25" href="#__codelineno-8-25"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;str3 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">str3</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-8-26" name="__codelineno-8-26" href="#__codelineno-8-26"></a><span class="p">}</span>
<a id="__codelineno-8-27" name="__codelineno-8-27" href="#__codelineno-8-27"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-8-28" name="__codelineno-8-28" href="#__codelineno-8-28"></a>
<a id="__codelineno-8-29" name="__codelineno-8-29" href="#__codelineno-8-29"></a><span class="w">    </span><span class="n">test01</span><span class="p">();</span>
<a id="__codelineno-8-30" name="__codelineno-8-30" href="#__codelineno-8-30"></a>
<a id="__codelineno-8-31" name="__codelineno-8-31" href="#__codelineno-8-31"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-8-32" name="__codelineno-8-32" href="#__codelineno-8-32"></a>
<a id="__codelineno-8-33" name="__codelineno-8-33" href="#__codelineno-8-33"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-8-34" name="__codelineno-8-34" href="#__codelineno-8-34"></a><span class="p">}</span>
</code></pre></div></p>
<p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p>
<h4 id="315-string">3.1.5 string查找和替换 <strong>功能描述：</strong> * 查找：查找指定字符串是否存在<a class="headerlink" href="#315-string" title="Permanent link">&para;</a></h4>
<ul>
<li>替换：在指定的位置替换字符串 <strong>函数原型：</strong> * <code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos = 0) const;</code>                     //查找s第一次出现位置,从pos开始查找</li>
<li><code>int find(const char* s, int pos, int n) const;</code>               //从pos位置查找s的前n个字符第一次位置</li>
<li><code>int find(const char c, int pos = 0) const;</code>                       //查找字符c第一次出现位置</li>
<li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li>
<li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li>
<li><code>int rfind(const char c, int pos = 0) const;</code>                      //查找字符c最后一次出现位置</li>
<li><code>string&amp; replace(int pos, int n, const string&amp; str);</code>       //替换从pos开始n个字符为字符串str</li>
<li><code>string&amp; replace(int pos, int n,const char* s);</code>                 //替换从pos开始的n个字符为字符串s</li>
</ul>
<p><strong>示例：</strong> ```C++
//查找和替换
void test01()
{
    //查找
    string str1 = "abcdefgde";</p>
<div class="highlight"><pre><span></span><code>int pos = str1.find(&quot;de&quot;);

if (pos == -1)
{
    cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
}
else
{
    cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;
}


pos = str1.rfind(&quot;de&quot;);

cout &lt;&lt; &quot;pos = &quot; &lt;&lt; pos &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>void test02()
{
    //替换
    string str1 = "abcdefgde";
    str1.replace(1, 3, "1111");</p>
<div class="highlight"><pre><span></span><code>cout &lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>//test01();
//test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* find查找是从左往后，rfind从右往左
* find找到字符串后返回查找的第一个字符位置，找不到返回-1
* replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串















</p>
<h4 id="316-string-ascii">3.1.6 string字符串比较 <strong>功能描述：</strong> * 字符串之间的比较 <strong>比较方式：</strong> * 字符串比较是按字符的ASCII码进行对比<a class="headerlink" href="#316-string-ascii" title="Permanent link">&para;</a></h4>
<p>= 返回   0

> 返回   1 

&lt; 返回  -1 <strong>函数原型：</strong> * <code>int compare(const string &amp;s) const;</code>  //与字符串s比较
* <code>int compare(const char *s) const;</code>      //与字符串s比较



 <strong>示例：</strong> <code>C++
//字符串比较
void test01()
{

    string s1 = "hello";
    string s2 = "aello";

    int ret = s1.compare(s2);

    if (ret == 0) {
        cout &lt;&lt; "s1 等于 s2" &lt;&lt; endl;
    }
    else if (ret &gt; 0)
    {
        cout &lt;&lt; "s1 大于 s2" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "s1 小于 s2" &lt;&lt; endl;
    }

}

int main() {

    test01();

    system("pause");

    return 0;
}</code></p>
<p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p>
<h4 id="317-string">3.1.7 string字符存取<a class="headerlink" href="#317-string" title="Permanent link">&para;</a></h4>
<p>string中单个字符存取方式有两种</p>
<ul>
<li><code>char&amp; operator[](int n);</code>     //通过[]方式取字符</li>
<li><code>char&amp; at(int n);</code>                    //通过at方法获取字符</li>
</ul>
<p><strong>示例：</strong> ```C++
void test01()
{
    string str = "hello world";</p>
<div class="highlight"><pre><span></span><code>for (int i = 0; i &lt; str.size(); i++)
{
    cout &lt;&lt; str[i] &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;

for (int i = 0; i &lt; str.size(); i++)
{
    cout &lt;&lt; str.at(i) &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;


//字符修改
str[0] = &#39;x&#39;;
str.at(1) = &#39;x&#39;;
cout &lt;&lt; str &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at








</p>
<h4 id="318-string-string-string-insertint-pos-const-char-s">3.1.8 string插入和删除 <strong>功能描述：</strong> * 对string字符串进行插入和删除字符操作 <strong>函数原型：</strong> * <code>string&amp; insert(int pos, const char* s);</code>                //插入字符串<a class="headerlink" href="#318-string-string-string-insertint-pos-const-char-s" title="Permanent link">&para;</a></h4>
<ul>
<li><code>string&amp; insert(int pos, const string&amp; str);</code>        //插入字符串</li>
<li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li>
<li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 



 <strong>示例：</strong> <code>C++
//字符串插入和删除
void test01()
{
    string str = "hello";
    str.insert(1, "111");
    cout &lt;&lt; str &lt;&lt; endl;

    str.erase(1, 3);  //从1号位置开始3个字符
    cout &lt;&lt; str &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}</code> <strong>总结：</strong> 插入和删除的起始下标都是从0开始










</li>
</ul>
<h4 id="319-string-string-substrint-pos-0-int-n-npos-const-posn">3.1.9 string子串 <strong>功能描述：</strong> * 从字符串中获取想要的子串 <strong>函数原型：</strong> * <code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串<a class="headerlink" href="#319-string-string-substrint-pos-0-int-n-npos-const-posn" title="Permanent link">&para;</a></h4>
<p><strong>示例：</strong> <code>C++
//子串
void test01()
{

    string str = "abcdefg";
    string subStr = str.substr(1, 3);
    cout &lt;&lt; "subStr = " &lt;&lt; subStr &lt;&lt; endl;

    string email = "hello@sina.com";
    int pos = email.find("@");
    string username = email.substr(0, pos);
    cout &lt;&lt; "username: " &lt;&lt; username &lt;&lt; endl;

}

int main() {

    test01();

    system("pause");

    return 0;
}</code> <strong>总结：</strong> 灵活的运用求子串功能，可以在实际开发中获取有效的信息






</p>
<h3 id="32-vector">3.2 vector容器<a class="headerlink" href="#32-vector" title="Permanent link">&para;</a></h3>
<h4 id="321-vector-vector-vector-vector">3.2.1 vector基本概念 <strong>功能：</strong> * vector数据结构和 <strong>数组非常相似</strong> ，也称为 <strong>单端数组</strong>  <strong>vector与普通数组区别：</strong> * 不同之处在于数组是静态空间，而vector可以 <strong>动态扩展</strong>  <strong>动态扩展：</strong> * 并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间<a class="headerlink" href="#321-vector-vector-vector-vector" title="Permanent link">&para;</a></h4>
<p><img alt="说明: 2015-11-10_151152" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217865.jpg" />



* vector容器的迭代器是支持随机访问的迭代器




</p>
<h4 id="322-vector">3.2.2 vector构造函数<a class="headerlink" href="#322-vector" title="Permanent link">&para;</a></h4>
<p><strong>功能描述：</strong> * 创建vector容器 <strong>函数原型：</strong> * <code>vector&lt;T&gt; v;</code>                          //采用模板实现类实现，默认构造函数
* <code>vector(v.begin(), v.end());</code>       //将v[begin(), end())区间中的元素拷贝给本身。
* <code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。
* <code>vector(const vector &amp;vec);</code>         //拷贝构造函数。


 <strong>示例：</strong> 
```C++</p>
<h1 id="include_9">include <vector><a class="headerlink" href="#include_9" title="Permanent link">&para;</a></h1>
<p>void printVector(vector<int>&amp; v) {

    for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
        cout &lt;&lt; <em>it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

void test01()
{
    vector<int> v1; //无参构造
    for (int i = 0; i &lt; 10; i++)
    {
        v1.push_back(i);
    }
    printVector(v1);

    vector<int> v2(v1.begin(), v1.end());
    printVector(v2);

    vector<int> v3(10, 100);
    printVector(v3);

    vector<int> v4(v3);
    printVector(v4);
}

int main() {

    test01();

    system("pause");

    return 0;
}
``` **总结：*</em> vector的多种构造方式没有可比性，灵活使用即可








</p>
<h4 id="323-vector">3.2.3 vector赋值操作<a class="headerlink" href="#323-vector" title="Permanent link">&para;</a></h4>
<p><strong>功能描述：</strong> * 给vector容器进行赋值 <strong>函数原型：</strong> * <code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符


* <code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。
* <code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。



 <strong>示例：</strong> ```C++</p>
<h1 id="include_10">include <vector><a class="headerlink" href="#include_10" title="Permanent link">&para;</a></h1>
<p>void printVector(vector<int>&amp; v) {

    for (vector<int>::iterator it = v.begin(); it != v.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

//赋值操作
void test01()
{
    vector<int> v1; //无参构造
    for (int i = 0; i &lt; 10; i++)
    {
        v1.push_back(i);
    }
    printVector(v1);

    vector<int>v2;
    v2 = v1;
    printVector(v2);

    vector<int>v3;
    v3.assign(v1.begin(), v1.end());
    printVector(v3);

    vector<int>v4;
    v4.assign(10, 100);
    printVector(v4);
}

int main() {

    test01();

    system("pause");

    return 0;
}

```</p>
<p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p>
<h4 id="324-vector-vector-empty">3.2.4  vector容量和大小 <strong>功能描述：</strong> * 对vector容器的容量和大小操作 <strong>函数原型：</strong> * <code>empty();</code>                            //判断容器是否为空<a class="headerlink" href="#324-vector-vector-empty" title="Permanent link">&para;</a></h4>
<ul>
<li>
<p><code>capacity();</code>                      //容器的容量</p>
</li>
<li>
<p><code>size();</code>                              //返回容器中元素的个数</p>
</li>
<li>
<p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p>
</li>
</ul>
<p>​                       //如果容器变短，则末尾超出容器长度的元素被删除。</p>
<ul>
<li><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</li>
</ul>
<p>​                           //如果容器变短，则末尾超出容器长度的元素被删除</p>
<p><strong>示例：</strong> 
<div class="highlight"><pre><span></span><code><a id="__codelineno-11-1" name="__codelineno-11-1" href="#__codelineno-11-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;vector&gt;</span>
<a id="__codelineno-11-2" name="__codelineno-11-2" href="#__codelineno-11-2"></a>
<a id="__codelineno-11-3" name="__codelineno-11-3" href="#__codelineno-11-3"></a><span class="kt">void</span><span class="w"> </span><span class="nf">printVector</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="w"> </span><span class="n">v</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-11-4" name="__codelineno-11-4" href="#__codelineno-11-4"></a>
<a id="__codelineno-11-5" name="__codelineno-11-5" href="#__codelineno-11-5"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-11-6" name="__codelineno-11-6" href="#__codelineno-11-6"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-11-7" name="__codelineno-11-7" href="#__codelineno-11-7"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-11-8" name="__codelineno-11-8" href="#__codelineno-11-8"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-11-9" name="__codelineno-11-9" href="#__codelineno-11-9"></a><span class="p">}</span>
<a id="__codelineno-11-10" name="__codelineno-11-10" href="#__codelineno-11-10"></a>
<a id="__codelineno-11-11" name="__codelineno-11-11" href="#__codelineno-11-11"></a><span class="kt">void</span><span class="w"> </span><span class="nf">test01</span><span class="p">()</span>
<a id="__codelineno-11-12" name="__codelineno-11-12" href="#__codelineno-11-12"></a><span class="p">{</span>
<a id="__codelineno-11-13" name="__codelineno-11-13" href="#__codelineno-11-13"></a><span class="w">    </span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">v1</span><span class="p">;</span>
<a id="__codelineno-11-14" name="__codelineno-11-14" href="#__codelineno-11-14"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">10</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-11-15" name="__codelineno-11-15" href="#__codelineno-11-15"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-11-16" name="__codelineno-11-16" href="#__codelineno-11-16"></a><span class="w">        </span><span class="n">v1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<a id="__codelineno-11-17" name="__codelineno-11-17" href="#__codelineno-11-17"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-11-18" name="__codelineno-11-18" href="#__codelineno-11-18"></a><span class="w">    </span><span class="n">printVector</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>
<a id="__codelineno-11-19" name="__codelineno-11-19" href="#__codelineno-11-19"></a><span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">v1</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
<a id="__codelineno-11-20" name="__codelineno-11-20" href="#__codelineno-11-20"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-11-21" name="__codelineno-11-21" href="#__codelineno-11-21"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;v1为空&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-11-22" name="__codelineno-11-22" href="#__codelineno-11-22"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-11-23" name="__codelineno-11-23" href="#__codelineno-11-23"></a><span class="w">    </span><span class="k">else</span>
<a id="__codelineno-11-24" name="__codelineno-11-24" href="#__codelineno-11-24"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-11-25" name="__codelineno-11-25" href="#__codelineno-11-25"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;v1不为空&quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-11-26" name="__codelineno-11-26" href="#__codelineno-11-26"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;v1的容量 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">capacity</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-11-27" name="__codelineno-11-27" href="#__codelineno-11-27"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;v1的大小 = &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">v1</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-11-28" name="__codelineno-11-28" href="#__codelineno-11-28"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-11-29" name="__codelineno-11-29" href="#__codelineno-11-29"></a>
<a id="__codelineno-11-30" name="__codelineno-11-30" href="#__codelineno-11-30"></a><span class="w">    </span><span class="c1">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span>
<a id="__codelineno-11-31" name="__codelineno-11-31" href="#__codelineno-11-31"></a><span class="w">    </span><span class="n">v1</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">15</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-11-32" name="__codelineno-11-32" href="#__codelineno-11-32"></a><span class="w">    </span><span class="n">printVector</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>
<a id="__codelineno-11-33" name="__codelineno-11-33" href="#__codelineno-11-33"></a>
<a id="__codelineno-11-34" name="__codelineno-11-34" href="#__codelineno-11-34"></a><span class="w">    </span><span class="c1">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span>
<a id="__codelineno-11-35" name="__codelineno-11-35" href="#__codelineno-11-35"></a><span class="w">    </span><span class="n">v1</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
<a id="__codelineno-11-36" name="__codelineno-11-36" href="#__codelineno-11-36"></a><span class="w">    </span><span class="n">printVector</span><span class="p">(</span><span class="n">v1</span><span class="p">);</span>
<a id="__codelineno-11-37" name="__codelineno-11-37" href="#__codelineno-11-37"></a><span class="p">}</span>
<a id="__codelineno-11-38" name="__codelineno-11-38" href="#__codelineno-11-38"></a>
<a id="__codelineno-11-39" name="__codelineno-11-39" href="#__codelineno-11-39"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-11-40" name="__codelineno-11-40" href="#__codelineno-11-40"></a>
<a id="__codelineno-11-41" name="__codelineno-11-41" href="#__codelineno-11-41"></a><span class="w">    </span><span class="n">test01</span><span class="p">();</span>
<a id="__codelineno-11-42" name="__codelineno-11-42" href="#__codelineno-11-42"></a>
<a id="__codelineno-11-43" name="__codelineno-11-43" href="#__codelineno-11-43"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-11-44" name="__codelineno-11-44" href="#__codelineno-11-44"></a>
<a id="__codelineno-11-45" name="__codelineno-11-45" href="#__codelineno-11-45"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-11-46" name="__codelineno-11-46" href="#__codelineno-11-46"></a><span class="p">}</span>
</code></pre></div></p>
<p>总结：</p>
<ul>
<li>判断是否为空  --- empty</li>
<li>返回元素个数  --- size</li>
<li>返回容器容量  --- capacity</li>
<li>重新指定大小  ---  resize</li>
</ul>
<h4 id="325-vector-vector-push_backele-ele">3.2.5 vector插入和删除 <strong>功能描述：</strong> * 对vector容器进行插入、删除操作 <strong>函数原型：</strong> * <code>push_back(ele);</code>                                         //尾部插入元素ele<a class="headerlink" href="#325-vector-vector-push_backele-ele" title="Permanent link">&para;</a></h4>
<ul>
<li><code>pop_back();</code>                                                //删除最后一个元素</li>
<li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li>
<li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li>
<li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li>
<li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li>
<li><code>clear();</code>                                                        //删除容器中所有元素</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_11">include <vector><a class="headerlink" href="#include_11" title="Permanent link">&para;</a></h1>
<p>void printVector(vector<int>&amp; v) {</p>
<div class="highlight"><pre><span></span><code>for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>//插入和删除
void test01()
{
    vector<int> v1;
    //尾插
    v1.push_back(10);
    v1.push_back(20);
    v1.push_back(30);
    v1.push_back(40);
    v1.push_back(50);
    printVector(v1);
    //尾删
    v1.pop_back();
    printVector(v1);
    //插入
    v1.insert(v1.begin(), 100);
    printVector(v1);</p>
<div class="highlight"><pre><span></span><code>v1.insert(v1.begin(), 2, 1000);
printVector(v1);

//删除
v1.erase(v1.begin());
printVector(v1);

//清空
v1.erase(v1.begin(), v1.end());
v1.clear();
printVector(v1);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* 尾插  --- push_back
* 尾删  --- pop_back
* 插入  --- insert    (位置迭代器)
* 删除  --- erase  （位置迭代器）
* 清空  ---  clear<br />
</p>
<h4 id="326-vector">3.2.6 vector数据存取<a class="headerlink" href="#326-vector" title="Permanent link">&para;</a></h4>
<p><strong>功能描述：</strong> * 对vector中的数据的存取操作 <strong>函数原型：</strong> * <code>at(int idx);</code>     //返回索引idx所指的数据
* <code>operator[];</code>       //返回索引idx所指的数据
* <code>front();</code>            //返回容器中第一个数据元素
* <code>back();</code>              //返回容器中最后一个数据元素



 <strong>示例：</strong> ```C++</p>
<h1 id="include_12">include <vector><a class="headerlink" href="#include_12" title="Permanent link">&para;</a></h1>
<p>void test01()
{
    vector<int>v1;
    for (int i = 0; i &lt; 10; i++)
    {
        v1.push_back(i);
    }

    for (int i = 0; i &lt; v1.size(); i++)
    {
        cout &lt;&lt; v1[i] &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    for (int i = 0; i &lt; v1.size(); i++)
    {
        cout &lt;&lt; v1.at(i) &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    cout &lt;&lt; "v1的第一个元素为： " &lt;&lt; v1.front() &lt;&lt; endl;
    cout &lt;&lt; "v1的最后一个元素为： " &lt;&lt; v1.back() &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="327-vector-swapvec-vec">3.2.7 vector互换容器 <strong>功能描述：</strong> * 实现两个容器内元素进行互换 <strong>函数原型：</strong> * <code>swap(vec);</code>  // 将vec与本身的元素互换<a class="headerlink" href="#327-vector-swapvec-vec" title="Permanent link">&para;</a></h4>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_13">include <vector><a class="headerlink" href="#include_13" title="Permanent link">&para;</a></h1>
<p>void printVector(vector<int>&amp; v) {</p>
<div class="highlight"><pre><span></span><code>for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>void test01()
{
    vector<int>v1;
    for (int i = 0; i &lt; 10; i++)
    {
        v1.push_back(i);
    }
    printVector(v1);</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt;v2;
for (int i = 10; i &gt; 0; i--)
{
    v2.push_back(i);
}
printVector(v2);

//互换容器
cout &lt;&lt; &quot;互换后&quot; &lt;&lt; endl;
v1.swap(v2);
printVector(v1);
printVector(v2);
</code></pre></div>
<p>}</p>
<p>void test02()
{
    vector<int> v;
    for (int i = 0; i &lt; 100000; i++) {
        v.push_back(i);
    }</p>
<div class="highlight"><pre><span></span><code>cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

v.resize(3);

cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;

//收缩内存
vector&lt;int&gt;(v).swap(v); //匿名对象

cout &lt;&lt; &quot;v的容量为：&quot; &lt;&lt; v.capacity() &lt;&lt; endl;
cout &lt;&lt; &quot;v的大小为：&quot; &lt;&lt; v.size() &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-13-1" name="__codelineno-13-1" href="#__codelineno-13-1"></a>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果
<a id="__codelineno-13-2" name="__codelineno-13-2" href="#__codelineno-13-2"></a>
<a id="__codelineno-13-3" name="__codelineno-13-3" href="#__codelineno-13-3"></a>
<a id="__codelineno-13-4" name="__codelineno-13-4" href="#__codelineno-13-4"></a>
<a id="__codelineno-13-5" name="__codelineno-13-5" href="#__codelineno-13-5"></a>
<a id="__codelineno-13-6" name="__codelineno-13-6" href="#__codelineno-13-6"></a>
<a id="__codelineno-13-7" name="__codelineno-13-7" href="#__codelineno-13-7"></a>
<a id="__codelineno-13-8" name="__codelineno-13-8" href="#__codelineno-13-8"></a>
<a id="__codelineno-13-9" name="__codelineno-13-9" href="#__codelineno-13-9"></a>
<a id="__codelineno-13-10" name="__codelineno-13-10" href="#__codelineno-13-10"></a>
<a id="__codelineno-13-11" name="__codelineno-13-11" href="#__codelineno-13-11"></a>#### 3.2.8 vector预留空间 **功能描述：** * 减少vector在动态扩展容量时的扩展次数 **函数原型：** * `reserve(int len);`//容器预留len个元素长度，预留位置不初始化，元素不可访问。
<a id="__codelineno-13-12" name="__codelineno-13-12" href="#__codelineno-13-12"></a>
<a id="__codelineno-13-13" name="__codelineno-13-13" href="#__codelineno-13-13"></a> **示例：** ```C++
<a id="__codelineno-13-14" name="__codelineno-13-14" href="#__codelineno-13-14"></a>#include &lt;vector&gt;
<a id="__codelineno-13-15" name="__codelineno-13-15" href="#__codelineno-13-15"></a>
<a id="__codelineno-13-16" name="__codelineno-13-16" href="#__codelineno-13-16"></a>void test01()
<a id="__codelineno-13-17" name="__codelineno-13-17" href="#__codelineno-13-17"></a>{
<a id="__codelineno-13-18" name="__codelineno-13-18" href="#__codelineno-13-18"></a>    vector&lt;int&gt; v;
<a id="__codelineno-13-19" name="__codelineno-13-19" href="#__codelineno-13-19"></a>
<a id="__codelineno-13-20" name="__codelineno-13-20" href="#__codelineno-13-20"></a>    //预留空间
<a id="__codelineno-13-21" name="__codelineno-13-21" href="#__codelineno-13-21"></a>    v.reserve(100000);
<a id="__codelineno-13-22" name="__codelineno-13-22" href="#__codelineno-13-22"></a>
<a id="__codelineno-13-23" name="__codelineno-13-23" href="#__codelineno-13-23"></a>    int num = 0;
<a id="__codelineno-13-24" name="__codelineno-13-24" href="#__codelineno-13-24"></a>    int* p = NULL;
<a id="__codelineno-13-25" name="__codelineno-13-25" href="#__codelineno-13-25"></a>    for (int i = 0; i &lt; 100000; i++) {
<a id="__codelineno-13-26" name="__codelineno-13-26" href="#__codelineno-13-26"></a>        v.push_back(i);
<a id="__codelineno-13-27" name="__codelineno-13-27" href="#__codelineno-13-27"></a>        if (p != &amp;v[0]) {
<a id="__codelineno-13-28" name="__codelineno-13-28" href="#__codelineno-13-28"></a>            p = &amp;v[0];
<a id="__codelineno-13-29" name="__codelineno-13-29" href="#__codelineno-13-29"></a>            num++;
<a id="__codelineno-13-30" name="__codelineno-13-30" href="#__codelineno-13-30"></a>        }
<a id="__codelineno-13-31" name="__codelineno-13-31" href="#__codelineno-13-31"></a>    }
<a id="__codelineno-13-32" name="__codelineno-13-32" href="#__codelineno-13-32"></a>
<a id="__codelineno-13-33" name="__codelineno-13-33" href="#__codelineno-13-33"></a>    cout &lt;&lt; &quot;num:&quot; &lt;&lt; num &lt;&lt; endl;
<a id="__codelineno-13-34" name="__codelineno-13-34" href="#__codelineno-13-34"></a>}
<a id="__codelineno-13-35" name="__codelineno-13-35" href="#__codelineno-13-35"></a>
<a id="__codelineno-13-36" name="__codelineno-13-36" href="#__codelineno-13-36"></a>int main() {
<a id="__codelineno-13-37" name="__codelineno-13-37" href="#__codelineno-13-37"></a>
<a id="__codelineno-13-38" name="__codelineno-13-38" href="#__codelineno-13-38"></a>    test01();
<a id="__codelineno-13-39" name="__codelineno-13-39" href="#__codelineno-13-39"></a>
<a id="__codelineno-13-40" name="__codelineno-13-40" href="#__codelineno-13-40"></a>    system(&quot;pause&quot;);
<a id="__codelineno-13-41" name="__codelineno-13-41" href="#__codelineno-13-41"></a>
<a id="__codelineno-13-42" name="__codelineno-13-42" href="#__codelineno-13-42"></a>    return 0;
<a id="__codelineno-13-43" name="__codelineno-13-43" href="#__codelineno-13-43"></a>}
</code></pre></div>
<p>总结：如果数据量较大，可以一开始利用reserve预留空间</p>
<h3 id="33-deque">3.3 deque容器<a class="headerlink" href="#33-deque" title="Permanent link">&para;</a></h3>
<h4 id="331-deque">3.3.1 deque容器基本概念<a class="headerlink" href="#331-deque" title="Permanent link">&para;</a></h4>
<p><strong>功能：</strong> * 双端数组，可以对头端进行插入删除操作 <strong>deque与vector区别：</strong> * vector对于头部的插入删除效率低，数据量越大，效率越低
* deque相对而言，对头部的插入删除速度回比vector快
* vector访问元素时的速度会比deque快,这和两者内部实现有关</p>
<p><img alt="说明: 2015-11-19_204101" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217204.jpg" /></p>
<p>deque内部工作原理:</p>
<p>deque内部有个 <strong>中控器</strong> ，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
<p><img alt="clip_image002-1547547896341" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217666.jpg" /></p>
<ul>
<li>deque容器的迭代器也是支持随机访问的</li>
</ul>
<h4 id="332-deque-deque-dequet-deqt">3.3.2 deque构造函数 <strong>功能描述：</strong> * deque容器构造 <strong>函数原型：</strong> * <code>deque&lt;T&gt;</code> deqT;                      //默认构造形式<a class="headerlink" href="#332-deque-deque-dequet-deqt" title="Permanent link">&para;</a></h4>
<ul>
<li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li>
<li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_14">include <deque><a class="headerlink" href="#include_14" title="Permanent link">&para;</a></h1>
<p>void printDeque(const deque<int>&amp; d) 
{
    for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";</p>
<div class="highlight"><pre><span></span><code>}
cout &lt;&lt; endl;
</code></pre></div>
<p>}
//deque构造
void test01() {</p>
<div class="highlight"><pre><span></span><code>deque&lt;int&gt; d1; //无参构造函数
for (int i = 0; i &lt; 10; i++)
{
    d1.push_back(i);
}
printDeque(d1);
deque&lt;int&gt; d2(d1.begin(),d1.end());
printDeque(d2);

deque&lt;int&gt;d3(10,100);
printDeque(d3);

deque&lt;int&gt;d4 = d3;
printDeque(d4);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> deque容器和vector容器的构造方式几乎一致，灵活使用即可</p>
<h4 id="333-deque">3.3.3 deque赋值操作<a class="headerlink" href="#333-deque" title="Permanent link">&para;</a></h4>
<p><strong>功能描述：</strong> * 给deque容器进行赋值 <strong>函数原型：</strong> * <code>deque&amp; operator=(const deque &amp;deq);</code>         //重载等号操作符</p>
<ul>
<li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li>
<li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_15">include <deque><a class="headerlink" href="#include_15" title="Permanent link">&para;</a></h1>
<p>void printDeque(const deque<int>&amp; d) 
{
    for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";</p>
<div class="highlight"><pre><span></span><code>}
cout &lt;&lt; endl;
</code></pre></div>
<p>}
//赋值操作
void test01()
{
    deque<int> d1;
    for (int i = 0; i &lt; 10; i++)
    {
        d1.push_back(i);
    }
    printDeque(d1);</p>
<div class="highlight"><pre><span></span><code>deque&lt;int&gt;d2;
d2 = d1;
printDeque(d2);

deque&lt;int&gt;d3;
d3.assign(d1.begin(), d1.end());
printDeque(d3);

deque&lt;int&gt;d4;
d4.assign(10, 100);
printDeque(d4);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：deque赋值操作也与vector相同，需熟练掌握






</p>
<h4 id="334-deque-deque-dequeempty">3.3.4 deque大小操作 <strong>功能描述：</strong> * 对deque容器的大小进行操作 <strong>函数原型：</strong> * <code>deque.empty();</code>                       //判断容器是否为空<a class="headerlink" href="#334-deque-deque-dequeempty" title="Permanent link">&para;</a></h4>
<ul>
<li><code>deque.size();</code>                         //返回容器中元素的个数
</li>
<li><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。

  ​                                      //如果容器变短，则末尾超出容器长度的元素被删除。
</li>
<li><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。

  ​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。



 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_16">include <deque><a class="headerlink" href="#include_16" title="Permanent link">&para;</a></h1>
<p>void printDeque(const deque<int>&amp; d) 
{
    for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";

    }
    cout &lt;&lt; endl;
}

//大小操作
void test01()
{
    deque<int> d1;
    for (int i = 0; i &lt; 10; i++)
    {
        d1.push_back(i);
    }
    printDeque(d1);

    //判断容器是否为空
    if (d1.empty()) {
        cout &lt;&lt; "d1为空!" &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; "d1不为空!" &lt;&lt; endl;
        //统计大小
        cout &lt;&lt; "d1的大小为：" &lt;&lt; d1.size() &lt;&lt; endl;
    }

    //重新指定大小
    d1.resize(15, 1);
    printDeque(d1);

    d1.resize(5);
    printDeque(d1);
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>deque没有容量的概念</li>
<li>判断是否为空   --- empty</li>
<li>返回元素个数   --- size</li>
<li>重新指定个数   --- resize</li>
</ul>
<h4 id="335-deque-deque">3.3.5 deque 插入和删除 <strong>功能描述：</strong> * 向deque容器中插入和删除数据 <strong>函数原型：</strong> 两端插入操作：<a class="headerlink" href="#335-deque-deque" title="Permanent link">&para;</a></h4>
<ul>
<li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li>
<li><code>push_front(elem);</code>        //在容器头部插入一个数据</li>
<li><code>pop_back();</code>                   //删除容器最后一个数据</li>
<li><code>pop_front();</code>                 //删除容器第一个数据</li>
</ul>
<p>指定位置操作：</p>
<ul>
<li>
<p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p>
</li>
<li>
<p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p>
</li>
<li>
<p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p>
</li>
<li>
<p><code>clear();</code>                           //清空容器的所有数据</p>
</li>
<li>
<p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p>
</li>
<li>
<p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p>
</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_17">include <deque><a class="headerlink" href="#include_17" title="Permanent link">&para;</a></h1>
<p>void printDeque(const deque<int>&amp; d) 
{
    for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";</p>
<div class="highlight"><pre><span></span><code>}
cout &lt;&lt; endl;
</code></pre></div>
<p>}
//两端操作
void test01()
{
    deque<int> d;
    //尾插
    d.push_back(10);
    d.push_back(20);
    //头插
    d.push_front(100);
    d.push_front(200);</p>
<div class="highlight"><pre><span></span><code>printDeque(d);

//尾删
d.pop_back();
//头删
d.pop_front();
printDeque(d);
</code></pre></div>
<p>}</p>
<p>//插入
void test02()
{
    deque<int> d;
    d.push_back(10);
    d.push_back(20);
    d.push_front(100);
    d.push_front(200);
    printDeque(d);</p>
<div class="highlight"><pre><span></span><code>d.insert(d.begin(), 1000);
printDeque(d);

d.insert(d.begin(), 2,10000);
printDeque(d);

deque&lt;int&gt;d2;
d2.push_back(1);
d2.push_back(2);
d2.push_back(3);

d.insert(d.begin(), d2.begin(), d2.end());
printDeque(d);
</code></pre></div>
<p>}</p>
<p>//删除
void test03()
{
    deque<int> d;
    d.push_back(10);
    d.push_back(20);
    d.push_front(100);
    d.push_front(200);
    printDeque(d);</p>
<div class="highlight"><pre><span></span><code>d.erase(d.begin());
printDeque(d);

d.erase(d.begin(), d.end());
d.clear();
printDeque(d);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>//test01();

//test02();

test03();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-15-1" name="__codelineno-15-1" href="#__codelineno-15-1"></a>总结：
<a id="__codelineno-15-2" name="__codelineno-15-2" href="#__codelineno-15-2"></a>
<a id="__codelineno-15-3" name="__codelineno-15-3" href="#__codelineno-15-3"></a>* 插入和删除提供的位置是迭代器！
<a id="__codelineno-15-4" name="__codelineno-15-4" href="#__codelineno-15-4"></a>* 尾插   ---  push_back
<a id="__codelineno-15-5" name="__codelineno-15-5" href="#__codelineno-15-5"></a>* 尾删   ---  pop_back
<a id="__codelineno-15-6" name="__codelineno-15-6" href="#__codelineno-15-6"></a>* 头插   ---  push_front
<a id="__codelineno-15-7" name="__codelineno-15-7" href="#__codelineno-15-7"></a>* 头删   ---  pop_front
<a id="__codelineno-15-8" name="__codelineno-15-8" href="#__codelineno-15-8"></a>
<a id="__codelineno-15-9" name="__codelineno-15-9" href="#__codelineno-15-9"></a>
<a id="__codelineno-15-10" name="__codelineno-15-10" href="#__codelineno-15-10"></a>
<a id="__codelineno-15-11" name="__codelineno-15-11" href="#__codelineno-15-11"></a>
<a id="__codelineno-15-12" name="__codelineno-15-12" href="#__codelineno-15-12"></a>
<a id="__codelineno-15-13" name="__codelineno-15-13" href="#__codelineno-15-13"></a>
<a id="__codelineno-15-14" name="__codelineno-15-14" href="#__codelineno-15-14"></a>
<a id="__codelineno-15-15" name="__codelineno-15-15" href="#__codelineno-15-15"></a>
<a id="__codelineno-15-16" name="__codelineno-15-16" href="#__codelineno-15-16"></a>
<a id="__codelineno-15-17" name="__codelineno-15-17" href="#__codelineno-15-17"></a>
<a id="__codelineno-15-18" name="__codelineno-15-18" href="#__codelineno-15-18"></a>
<a id="__codelineno-15-19" name="__codelineno-15-19" href="#__codelineno-15-19"></a>#### 3.3.6 deque 数据存取
<a id="__codelineno-15-20" name="__codelineno-15-20" href="#__codelineno-15-20"></a>
<a id="__codelineno-15-21" name="__codelineno-15-21" href="#__codelineno-15-21"></a> **功能描述：** * 对deque 中的数据的存取操作 **函数原型：** - `at(int idx); `     //返回索引idx所指的数据
<a id="__codelineno-15-22" name="__codelineno-15-22" href="#__codelineno-15-22"></a>- `operator[]; `      //返回索引idx所指的数据
<a id="__codelineno-15-23" name="__codelineno-15-23" href="#__codelineno-15-23"></a>- `front(); `            //返回容器中第一个数据元素
<a id="__codelineno-15-24" name="__codelineno-15-24" href="#__codelineno-15-24"></a>- `back();`              //返回容器中最后一个数据元素
<a id="__codelineno-15-25" name="__codelineno-15-25" href="#__codelineno-15-25"></a>
<a id="__codelineno-15-26" name="__codelineno-15-26" href="#__codelineno-15-26"></a> **示例：** ```C++
<a id="__codelineno-15-27" name="__codelineno-15-27" href="#__codelineno-15-27"></a>#include &lt;deque&gt;
<a id="__codelineno-15-28" name="__codelineno-15-28" href="#__codelineno-15-28"></a>
<a id="__codelineno-15-29" name="__codelineno-15-29" href="#__codelineno-15-29"></a>void printDeque(const deque&lt;int&gt;&amp; d) 
<a id="__codelineno-15-30" name="__codelineno-15-30" href="#__codelineno-15-30"></a>{
<a id="__codelineno-15-31" name="__codelineno-15-31" href="#__codelineno-15-31"></a>    for (deque&lt;int&gt;::const_iterator it = d.begin(); it != d.end(); it++) {
<a id="__codelineno-15-32" name="__codelineno-15-32" href="#__codelineno-15-32"></a>        cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
<a id="__codelineno-15-33" name="__codelineno-15-33" href="#__codelineno-15-33"></a>
<a id="__codelineno-15-34" name="__codelineno-15-34" href="#__codelineno-15-34"></a>    }
<a id="__codelineno-15-35" name="__codelineno-15-35" href="#__codelineno-15-35"></a>    cout &lt;&lt; endl;
<a id="__codelineno-15-36" name="__codelineno-15-36" href="#__codelineno-15-36"></a>}
<a id="__codelineno-15-37" name="__codelineno-15-37" href="#__codelineno-15-37"></a>
<a id="__codelineno-15-38" name="__codelineno-15-38" href="#__codelineno-15-38"></a>//数据存取
<a id="__codelineno-15-39" name="__codelineno-15-39" href="#__codelineno-15-39"></a>void test01()
<a id="__codelineno-15-40" name="__codelineno-15-40" href="#__codelineno-15-40"></a>{
<a id="__codelineno-15-41" name="__codelineno-15-41" href="#__codelineno-15-41"></a>
<a id="__codelineno-15-42" name="__codelineno-15-42" href="#__codelineno-15-42"></a>    deque&lt;int&gt; d;
<a id="__codelineno-15-43" name="__codelineno-15-43" href="#__codelineno-15-43"></a>    d.push_back(10);
<a id="__codelineno-15-44" name="__codelineno-15-44" href="#__codelineno-15-44"></a>    d.push_back(20);
<a id="__codelineno-15-45" name="__codelineno-15-45" href="#__codelineno-15-45"></a>    d.push_front(100);
<a id="__codelineno-15-46" name="__codelineno-15-46" href="#__codelineno-15-46"></a>    d.push_front(200);
<a id="__codelineno-15-47" name="__codelineno-15-47" href="#__codelineno-15-47"></a>
<a id="__codelineno-15-48" name="__codelineno-15-48" href="#__codelineno-15-48"></a>    for (int i = 0; i &lt; d.size(); i++) {
<a id="__codelineno-15-49" name="__codelineno-15-49" href="#__codelineno-15-49"></a>        cout &lt;&lt; d[i] &lt;&lt; &quot; &quot;;
<a id="__codelineno-15-50" name="__codelineno-15-50" href="#__codelineno-15-50"></a>    }
<a id="__codelineno-15-51" name="__codelineno-15-51" href="#__codelineno-15-51"></a>    cout &lt;&lt; endl;
<a id="__codelineno-15-52" name="__codelineno-15-52" href="#__codelineno-15-52"></a>
<a id="__codelineno-15-53" name="__codelineno-15-53" href="#__codelineno-15-53"></a>
<a id="__codelineno-15-54" name="__codelineno-15-54" href="#__codelineno-15-54"></a>    for (int i = 0; i &lt; d.size(); i++) {
<a id="__codelineno-15-55" name="__codelineno-15-55" href="#__codelineno-15-55"></a>        cout &lt;&lt; d.at(i) &lt;&lt; &quot; &quot;;
<a id="__codelineno-15-56" name="__codelineno-15-56" href="#__codelineno-15-56"></a>    }
<a id="__codelineno-15-57" name="__codelineno-15-57" href="#__codelineno-15-57"></a>    cout &lt;&lt; endl;
<a id="__codelineno-15-58" name="__codelineno-15-58" href="#__codelineno-15-58"></a>
<a id="__codelineno-15-59" name="__codelineno-15-59" href="#__codelineno-15-59"></a>    cout &lt;&lt; &quot;front:&quot; &lt;&lt; d.front() &lt;&lt; endl;
<a id="__codelineno-15-60" name="__codelineno-15-60" href="#__codelineno-15-60"></a>
<a id="__codelineno-15-61" name="__codelineno-15-61" href="#__codelineno-15-61"></a>    cout &lt;&lt; &quot;back:&quot; &lt;&lt; d.back() &lt;&lt; endl;
<a id="__codelineno-15-62" name="__codelineno-15-62" href="#__codelineno-15-62"></a>
<a id="__codelineno-15-63" name="__codelineno-15-63" href="#__codelineno-15-63"></a>}
<a id="__codelineno-15-64" name="__codelineno-15-64" href="#__codelineno-15-64"></a>
<a id="__codelineno-15-65" name="__codelineno-15-65" href="#__codelineno-15-65"></a>int main() {
<a id="__codelineno-15-66" name="__codelineno-15-66" href="#__codelineno-15-66"></a>
<a id="__codelineno-15-67" name="__codelineno-15-67" href="#__codelineno-15-67"></a>    test01();
<a id="__codelineno-15-68" name="__codelineno-15-68" href="#__codelineno-15-68"></a>
<a id="__codelineno-15-69" name="__codelineno-15-69" href="#__codelineno-15-69"></a>    system(&quot;pause&quot;);
<a id="__codelineno-15-70" name="__codelineno-15-70" href="#__codelineno-15-70"></a>
<a id="__codelineno-15-71" name="__codelineno-15-71" href="#__codelineno-15-71"></a>    return 0;
<a id="__codelineno-15-72" name="__codelineno-15-72" href="#__codelineno-15-72"></a>}
</code></pre></div>
<p>总结：</p>
<ul>
<li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li>
<li>front返回容器第一个元素</li>
<li>back返回容器最后一个元素</li>
</ul>
<h4 id="337-deque-deque">3.3.7  deque 排序 <strong>功能描述：</strong> * 利用算法实现对deque容器进行排序<a class="headerlink" href="#337-deque-deque" title="Permanent link">&para;</a></h4>
<p><strong>算法：</strong> </p>
<ul>
<li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_18">include <deque><a class="headerlink" href="#include_18" title="Permanent link">&para;</a></h1>
<h1 id="include_19">include <algorithm><a class="headerlink" href="#include_19" title="Permanent link">&para;</a></h1>
<p>void printDeque(const deque<int>&amp; d) 
{
    for (deque<int>::const_iterator it = d.begin(); it != d.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";</p>
<div class="highlight"><pre><span></span><code>}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>void test01()
{</p>
<div class="highlight"><pre><span></span><code>deque&lt;int&gt; d;
d.push_back(10);
d.push_back(20);
d.push_front(100);
d.push_front(200);

printDeque(d);
sort(d.begin(), d.end());
printDeque(d);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：sort算法非常实用，使用时包含头文件 algorithm即可










</p>
<h3 id="34-">3.4 案例-评委打分<a class="headerlink" href="#34-" title="Permanent link">&para;</a></h3>
<h4 id="341">3.4.1 案例描述<a class="headerlink" href="#341" title="Permanent link">&para;</a></h4>
<p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。


</p>
<h4 id="342">3.4.2 实现步骤<a class="headerlink" href="#342" title="Permanent link">&para;</a></h4>
<ol>
<li>创建五名选手，放到vector中</li>
<li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li>
<li>sort算法对deque容器中分数排序，去除最高和最低分</li>
<li>deque容器遍历一遍，累加总分</li>
<li>获取平均分 <strong>示例代码：</strong> <code>C++
//选手类
class Person
{
public:
    Person(string name, int score)
    {
        this-&gt;m_Name = name;
        this-&gt;m_Score = score;
    }

    string m_Name; //姓名
    int m_Score;  //平均分
};

void createPerson(vector&lt;Person&gt;&amp;v)
{
    string nameSeed = "ABCDE";
    for (int i = 0; i &lt; 5; i++)
    {
        string name = "选手";
        name += nameSeed[i];

        int score = 0;

        Person p(name, score);

        //将创建的person对象 放入到容器中
        v.push_back(p);
    }
}

//打分
void setScore(vector&lt;Person&gt;&amp;v)
{
    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
    {
        //将评委的分数 放入到deque容器中
        deque&lt;int&gt;d;
        for (int i = 0; i &lt; 10; i++)
        {
            int score = rand() % 41 + 60;  // 60 ~ 100
            d.push_back(score);
        }

        //cout &lt;&lt; "选手： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 打分： " &lt;&lt; endl;
        //for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)
        //{
        //  cout &lt;&lt; *dit &lt;&lt; " ";
        //}
        //cout &lt;&lt; endl;

        //排序
        sort(d.begin(), d.end());

        //去除最高和最低分
        d.pop_back();
        d.pop_front();

        //取平均分
        int sum = 0;
        for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)
        {
            sum += *dit; //累加每个评委的分数
        }

        int avg = sum / d.size();

        //将平均分 赋值给选手身上
        it-&gt;m_Score = avg;
    }

}

void showScore(vector&lt;Person&gt;&amp;v)
{
    for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
    {
        cout &lt;&lt; "姓名： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 平均分： " &lt;&lt; it-&gt;m_Score &lt;&lt; endl;
    }
}

int main() {

    //随机数种子
    srand((unsigned int)time(NULL));

    //1、创建5名选手
    vector&lt;Person&gt;v;  //存放选手容器
    createPerson(v);

    //测试
    //for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)
    //{
    //  cout &lt;&lt; "姓名： " &lt;&lt; (*it).m_Name &lt;&lt; " 分数： " &lt;&lt; (*it).m_Score &lt;&lt; endl;
    //}

    //2、给5名选手打分
    setScore(v);

    //3、显示最后得分
    showScore(v);

    system("pause");

    return 0;
}</code> <strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率






</li>
</ol>
<h3 id="35-stack">3.5 stack容器<a class="headerlink" href="#35-stack" title="Permanent link">&para;</a></h3>
<h4 id="351-stack-stack-first-in-last-outfilo">3.5.1 stack 基本概念 <strong>概念：</strong> stack是一种 <strong>先进后出</strong> (First In Last Out,FILO)的数据结构，它只有一个出口<a class="headerlink" href="#351-stack-stack-first-in-last-outfilo" title="Permanent link">&para;</a></h4>
<p><img alt="说明: 2015-11-15_195707" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217922.jpg" />

栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为

栈中进入数据称为  --- <strong>入栈</strong> <code>push</code>

栈中弹出数据称为  --- <strong>出栈</strong> <code>pop</code>



生活中的栈：

<img alt="img" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217519.png" />





<img alt="img" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217144.jpg" />


</p>
<h4 id="352-stack">3.5.2 stack 常用接口<a class="headerlink" href="#352-stack" title="Permanent link">&para;</a></h4>
<p>功能描述：栈容器常用的对外接口



构造函数：

* <code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式
* <code>stack(const stack &amp;stk);</code>            //拷贝构造函数

赋值操作：

* <code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符

数据存取：

* <code>push(elem);</code>      //向栈顶添加元素
* <code>pop();</code>                //从栈顶移除第一个元素
* <code>top();</code>                //返回栈顶元素

大小操作：

* <code>empty();</code>            //判断堆栈是否为空
* <code>size();</code>              //返回栈的大小



 <strong>示例：</strong> ```C++</p>
<h1 id="include_20">include <stack><a class="headerlink" href="#include_20" title="Permanent link">&para;</a></h1>
<p>//栈容器常用接口
void test01()
{
    //创建栈容器 栈容器必须符合先进后出
    stack<int> s;

    //向栈中添加元素，叫做 压栈 入栈
    s.push(10);
    s.push(20);
    s.push(30);

    while (!s.empty()) {
        //输出栈顶元素
        cout &lt;&lt; "栈顶元素为： " &lt;&lt; s.top() &lt;&lt; endl;
        //弹出栈顶元素
        s.pop();
    }
    cout &lt;&lt; "栈的大小为：" &lt;&lt; s.size() &lt;&lt; endl;

}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>入栈   --- push</li>
<li>出栈   --- pop</li>
<li>返回栈顶   --- top</li>
<li>判断栈是否为空   --- empty</li>
<li>返回栈大小   --- size</li>
</ul>
<h3 id="36-queue">3.6 queue 容器<a class="headerlink" href="#36-queue" title="Permanent link">&para;</a></h3>
<h4 id="361-queue-queue-first-in-first-outfifo">3.6.1 queue 基本概念 <strong>概念：</strong> Queue是一种 <strong>先进先出</strong> (First In First Out,FIFO)的数据结构，它有两个出口<a class="headerlink" href="#361-queue-queue-first-in-first-outfifo" title="Permanent link">&para;</a></h4>
<p><img alt="说明: 2015-11-15_214429" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131218961.jpg" /></p>
<p>队列容器允许从一端新增元素，从另一端移除元素</p>
<p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p>
<p>队列中进数据称为 --- <strong>入队</strong> <code>push</code></p>
<p>队列中出数据称为 --- <strong>出队</strong> <code>pop</code></p>
<p>生活中的队列：</p>
<p><img alt="1547606785041" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217223.png" /></p>
<h4 id="362-queue">3.6.2 queue 常用接口<a class="headerlink" href="#362-queue" title="Permanent link">&para;</a></h4>
<p>功能描述：栈容器常用的对外接口</p>
<p>构造函数：</p>
<ul>
<li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li>
<li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li>
</ul>
<p>赋值操作：</p>
<ul>
<li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li>
</ul>
<p>数据存取：</p>
<ul>
<li><code>push(elem);</code>                             //往队尾添加元素</li>
<li><code>pop();</code>                                      //从队头移除第一个元素</li>
<li><code>back();</code>                                    //返回最后一个元素</li>
<li><code>front();</code>                                  //返回第一个元素</li>
</ul>
<p>大小操作：</p>
<ul>
<li><code>empty();</code>            //判断堆栈是否为空</li>
<li><code>size();</code>              //返回栈的大小</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_21">include <queue><a class="headerlink" href="#include_21" title="Permanent link">&para;</a></h1>
<h1 id="include_22">include <string><a class="headerlink" href="#include_22" title="Permanent link">&para;</a></h1>
<p>class Person
{
public:
    Person(string name, int age)
    {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }</p>
<div class="highlight"><pre><span></span><code>string m_Name;
int m_Age;
</code></pre></div>
<p>};</p>
<p>void test01() {</p>
<div class="highlight"><pre><span></span><code>//创建队列
queue&lt;Person&gt; q;

//准备数据
Person p1(&quot;唐僧&quot;, 30);
Person p2(&quot;孙悟空&quot;, 1000);
Person p3(&quot;猪八戒&quot;, 900);
Person p4(&quot;沙僧&quot;, 800);

//向队列中添加元素  入队操作
q.push(p1);
q.push(p2);
q.push(p3);
q.push(p4);

//队列不提供迭代器，更不支持随机访问 
while (!q.empty()) {
    //输出队头元素
    cout &lt;&lt; &quot;队头元素-- 姓名： &quot; &lt;&lt; q.front().m_Name 
          &lt;&lt; &quot; 年龄： &quot;&lt;&lt; q.front().m_Age &lt;&lt; endl;

    cout &lt;&lt; &quot;队尾元素-- 姓名： &quot; &lt;&lt; q.back().m_Name  
          &lt;&lt; &quot; 年龄： &quot; &lt;&lt; q.back().m_Age &lt;&lt; endl;

    cout &lt;&lt; endl;
    //弹出队头元素
    q.pop();
}

cout &lt;&lt; &quot;队列大小为：&quot; &lt;&lt; q.size() &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

- 入队   --- push
- 出队   --- pop
- 返回队头元素   --- front
- 返回队尾元素   --- back
- 判断队是否为空   --- empty
- 返回队列大小   --- size














</p>
<h3 id="37-list">3.7 list容器<a class="headerlink" href="#37-list" title="Permanent link">&para;</a></h3>
<h4 id="371-list-list">3.7.1 list基本概念 <strong>功能：</strong> 将数据进行链式存储 <strong>链表</strong> （list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的<a class="headerlink" href="#371-list-list" title="Permanent link">&para;</a></h4>
<p>链表的组成：链表由一系列 <strong>结点</strong> 组成



结点的组成：一个是存储数据元素的 <strong>数据域</strong> ，另一个是存储下一个结点地址的 <strong>指针域</strong> STL中的链表是一个双向循环链表



<img alt="说明: 2015-11-15_225145" src="https://cdn.jsdelivr.net/gh/SnowOnVolcano/imagebed/202304131217765.jpg" />

由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于 <strong>双向迭代器</strong> list的优点：

* 采用动态存储分配，不会造成内存浪费和溢出
* 链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素

list的缺点：

* 链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大



List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。



总结：STL中 <strong>List和vector是两个最常被使用的容器</strong> ，各有优缺点




</p>
<h4 id="372-list-list-listt-lst-list">3.7.2  list构造函数 <strong>功能描述：</strong> * 创建list容器 <strong>函数原型：</strong> * <code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：<a class="headerlink" href="#372-list-list-listt-lst-list" title="Permanent link">&para;</a></h4>
<ul>
<li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li>
<li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li>
<li><code>list(const list &amp;lst);</code>            //拷贝构造函数。



 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_23">include <list><a class="headerlink" href="#include_23" title="Permanent link">&para;</a></h1>
<p>void printList(const list<int>&amp; L) {

    for (list<int>::const_iterator it = L.begin(); it != L.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

void test01()
{
    list<int>L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);

    printList(L1);

    list<int>L2(L1.begin(),L1.end());
    printList(L2);

    list<int>L3(L2);
    printList(L3);

    list<int>L4(10, 1000);
    printList(L4);
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p>
<h4 id="373-list-listlist-assignbeg-end-beg-end">3.7.3 list 赋值和交换 <strong>功能描述：</strong> * 给list容器进行赋值，以及交换list容器 <strong>函数原型：</strong> * <code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。<a class="headerlink" href="#373-list-listlist-assignbeg-end-beg-end" title="Permanent link">&para;</a></h4>
<ul>
<li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li>
<li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li>
<li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_24">include <list><a class="headerlink" href="#include_24" title="Permanent link">&para;</a></h1>
<p>void printList(const list<int>&amp; L) {</p>
<div class="highlight"><pre><span></span><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>//赋值和交换
void test01()
{
    list<int>L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);
    printList(L1);</p>
<div class="highlight"><pre><span></span><code>//赋值
list&lt;int&gt;L2;
L2 = L1;
printList(L2);

list&lt;int&gt;L3;
L3.assign(L2.begin(), L2.end());
printList(L3);

list&lt;int&gt;L4;
L4.assign(10, 100);
printList(L4);
</code></pre></div>
<p>}</p>
<p>//交换
void test02()
{</p>
<div class="highlight"><pre><span></span><code>list&lt;int&gt;L1;
L1.push_back(10);
L1.push_back(20);
L1.push_back(30);
L1.push_back(40);

list&lt;int&gt;L2;
L2.assign(10, 100);

cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;
printList(L1);
printList(L2);

cout &lt;&lt; endl;

L1.swap(L2);

cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;
printList(L1);
printList(L2);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>//test01();

test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：list赋值和交换操作能够灵活运用即可














</p>
<h4 id="374-list-list-size">3.7.4 list 大小操作 <strong>功能描述：</strong> * 对list容器的大小进行操作 <strong>函数原型：</strong> * <code>size();</code>                             //返回容器中元素的个数<a class="headerlink" href="#374-list-list-size" title="Permanent link">&para;</a></h4>
<ul>
<li><code>empty();</code>                           //判断容器是否为空
</li>
<li><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。

  ​                     //如果容器变短，则末尾超出容器长度的元素被删除。
</li>
<li><code>resize(num, elem);</code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。

   //如果容器变短，则末尾超出容器长度的元素被删除。

 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_25">include <list><a class="headerlink" href="#include_25" title="Permanent link">&para;</a></h1>
<p>void printList(const list<int>&amp; L) {

    for (list<int>::const_iterator it = L.begin(); it != L.end(); it++) {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

//大小操作
void test01()
{
    list<int>L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);

    if (L1.empty())
    {
        cout &lt;&lt; "L1为空" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "L1不为空" &lt;&lt; endl;
        cout &lt;&lt; "L1的大小为： " &lt;&lt; L1.size() &lt;&lt; endl;
    }

    //重新指定大小
    L1.resize(10);
    printList(L1);

    L1.resize(2);
    printList(L1);
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>判断是否为空   --- empty</li>
<li>返回元素个数   --- size</li>
<li>重新指定个数   --- resize</li>
</ul>
<h4 id="375-list-list-push_backelem">3.7.5 list 插入和删除 <strong>功能描述：</strong> * 对list容器进行数据的插入和删除 <strong>函数原型：</strong> * push_back(elem);//在容器尾部加入一个元素<a class="headerlink" href="#375-list-list-push_backelem" title="Permanent link">&para;</a></h4>
<ul>
<li>pop_back();//删除容器中最后一个元素</li>
<li>push_front(elem);//在容器开头插入一个元素</li>
<li>pop_front();//从容器开头移除第一个元素</li>
<li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li>
<li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li>
<li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li>
<li>clear();//移除容器的所有数据</li>
<li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li>
<li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li>
<li>remove(elem);//删除容器中所有与elem值匹配的元素。</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_26">include <list><a class="headerlink" href="#include_26" title="Permanent link">&para;</a></h1>
<p>void printList(const list<int>&amp; L) {</p>
<div class="highlight"><pre><span></span><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>//插入和删除
void test01()
{
    list<int> L;
    //尾插
    L.push_back(10);
    L.push_back(20);
    L.push_back(30);
    //头插
    L.push_front(100);
    L.push_front(200);
    L.push_front(300);</p>
<div class="highlight"><pre><span></span><code>printList(L);

//尾删
L.pop_back();
printList(L);

//头删
L.pop_front();
printList(L);

//插入
list&lt;int&gt;::iterator it = L.begin();
L.insert(++it, 1000);
printList(L);

//删除
it = L.begin();
L.erase(++it);
printList(L);

//移除
L.push_back(10000);
L.push_back(10000);
L.push_back(10000);
printList(L);
L.remove(10000);
printList(L);

//清空
L.clear();
printList(L);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* 尾插   --- push_back
* 尾删   --- pop_back
* 头插   --- push_front
* 头删   --- pop_front
* 插入   --- insert
* 删除   --- erase
* 移除   --- remove
* 清空   --- clear
















</p>
<h4 id="376-list-list-front">3.7.6 list 数据存取 <strong>功能描述：</strong> * 对list容器中数据进行存取 <strong>函数原型：</strong> * <code>front();</code>        //返回第一个元素。<a class="headerlink" href="#376-list-list-front" title="Permanent link">&para;</a></h4>
<ul>
<li><code>back();</code>         //返回最后一个元素。



 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_27">include <list><a class="headerlink" href="#include_27" title="Permanent link">&para;</a></h1>
<p>//数据存取
void test01()
{
    list<int>L1;
    L1.push_back(10);
    L1.push_back(20);
    L1.push_back(30);
    L1.push_back(40);


    //cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据
    //cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据
    cout &lt;&lt; "第一个元素为： " &lt;&lt; L1.front() &lt;&lt; endl;
    cout &lt;&lt; "最后一个元素为： " &lt;&lt; L1.back() &lt;&lt; endl;

    //list容器的迭代器是双向迭代器，不支持随机访问
    list<int>::iterator it = L1.begin();
    //it = it + 1;//错误，不可以跳跃访问，即使是+1
}

int main() {

    test01();

    system("pause");

    return 0;
}

```</p>
<p>总结：</p>
<ul>
<li>list容器中不可以通过[]或者at方式访问数据</li>
<li>返回第一个元素   --- front</li>
<li>返回最后一个元素   --- back</li>
</ul>
<h4 id="377-list-reverse">3.7.7 list 反转和排序 <strong>功能描述：</strong> * 将容器中的元素反转，以及将容器中的数据进行排序 <strong>函数原型：</strong> * <code>reverse();</code>   //反转链表<a class="headerlink" href="#377-list-reverse" title="Permanent link">&para;</a></h4>
<ul>
<li><code>sort();</code>        //链表排序</li>
</ul>
<p><strong>示例：</strong> ```C++
void printList(const list<int>&amp; L) {</p>
<div class="highlight"><pre><span></span><code>for (list&lt;int&gt;::const_iterator it = L.begin(); it != L.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>bool myCompare(int val1 , int val2)
{
    return val1 &gt; val2;
}</p>
<p>//反转和排序
void test01()
{
    list<int> L;
    L.push_back(90);
    L.push_back(30);
    L.push_back(20);
    L.push_back(70);
    printList(L);</p>
<div class="highlight"><pre><span></span><code>//反转容器的元素
L.reverse();
printList(L);

//排序
L.sort(); //默认的排序规则 从小到大
printList(L);

L.sort(myCompare); //指定规则，从大到小
printList(L);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* 反转   --- reverse
* 排序   --- sort （成员函数）










</p>
<h4 id="378">3.7.8 排序案例<a class="headerlink" href="#378" title="Permanent link">&para;</a></h4>
<p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高

排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序

 <strong>示例：</strong> ```C++</p>
<h1 id="include_28">include <list><a class="headerlink" href="#include_28" title="Permanent link">&para;</a></h1>
<h1 id="include_29">include <string><a class="headerlink" href="#include_29" title="Permanent link">&para;</a></h1>
<p>class Person {
public:
    Person(string name, int age , int height) {
        m_Name = name;
        m_Age = age;
        m_Height = height;
    }

public:
    string m_Name;  //姓名
    int m_Age;      //年龄
    int m_Height;   //身高
};


bool ComparePerson(Person&amp; p1, Person&amp; p2) {

    if (p1.m_Age == p2.m_Age) {
        return p1.m_Height  &gt; p2.m_Height;
    }
    else
    {
        return  p1.m_Age &lt; p2.m_Age;
    }

}

void test01() {

    list<Person> L;

    Person p1("刘备", 35 , 175);
    Person p2("曹操", 45 , 180);
    Person p3("孙权", 40 , 170);
    Person p4("赵云", 25 , 190);
    Person p5("张飞", 35 , 160);
    Person p6("关羽", 35 , 200);

    L.push_back(p1);
    L.push_back(p2);
    L.push_back(p3);
    L.push_back(p4);
    L.push_back(p5);
    L.push_back(p6);

    for (list<Person>::iterator it = L.begin(); it != L.end(); it++) {
        cout &lt;&lt; "姓名： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 年龄： " &lt;&lt; it-&gt;m_Age 
              &lt;&lt; " 身高： " &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
    }

    cout &lt;&lt; "---------------------------------" &lt;&lt; endl;
    L.sort(ComparePerson); //排序

    for (list<Person>::iterator it = L.begin(); it != L.end(); it++) {
        cout &lt;&lt; "姓名： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 年龄： " &lt;&lt; it-&gt;m_Age 
              &lt;&lt; " 身高： " &lt;&lt; it-&gt;m_Height &lt;&lt; endl;
    }
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>
<p>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</p>
</li>
<li>
<p>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</p>
</li>
</ul>
<h3 id="38-set-multiset">3.8 set/ multiset 容器<a class="headerlink" href="#38-set-multiset" title="Permanent link">&para;</a></h3>
<h4 id="381-set">3.8.1 set基本概念 <strong>简介：</strong> * 所有元素都会在插入时自动被排序<a class="headerlink" href="#381-set" title="Permanent link">&para;</a></h4>
<p><strong>本质：</strong> * set/multiset属于 <strong>关联式容器</strong> ，底层结构是用 <strong>二叉树</strong> 实现。 <strong>set和multiset区别</strong> ：</p>
<ul>
<li>set不允许容器中有重复的元素</li>
<li>multiset允许容器中有重复的元素</li>
</ul>
<h4 id="382-set">3.8.2 set构造和赋值<a class="headerlink" href="#382-set" title="Permanent link">&para;</a></h4>
<p>功能描述：创建set容器以及赋值</p>
<p>构造：</p>
<ul>
<li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li>
<li><code>set(const set &amp;st);</code>       //拷贝构造函数</li>
</ul>
<p>赋值：</p>
<ul>
<li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_30">include <set><a class="headerlink" href="#include_30" title="Permanent link">&para;</a></h1>
<p>void printSet(set<int> &amp; s)
{
    for (set<int>::iterator it = s.begin(); it != s.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}</p>
<p>//构造和赋值
void test01()
{
    set<int> s1;</p>
<div class="highlight"><pre><span></span><code>s1.insert(10);
s1.insert(30);
s1.insert(20);
s1.insert(40);
printSet(s1);

//拷贝构造
set&lt;int&gt;s2(s1);
printSet(s2);

//赋值
set&lt;int&gt;s3;
s3 = s2;
printSet(s3);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* set容器插入数据时用insert
* set容器插入数据的数据会自动排序










</p>
<h4 id="383-set-setset-size">3.8.3 set大小和交换 <strong>功能描述：</strong> * 统计set容器大小以及交换set容器 <strong>函数原型：</strong> * <code>size();</code>          //返回容器中元素的数目<a class="headerlink" href="#383-set-setset-size" title="Permanent link">&para;</a></h4>
<ul>
<li><code>empty();</code>        //判断容器是否为空</li>
<li><code>swap(st);</code>      //交换两个集合容器

 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_31">include <set><a class="headerlink" href="#include_31" title="Permanent link">&para;</a></h1>
<p>void printSet(set<int> &amp; s)
{
    for (set<int>::iterator it = s.begin(); it != s.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

//大小
void test01()
{

    set<int> s1;

    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);

    if (s1.empty())
    {
        cout &lt;&lt; "s1为空" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "s1不为空" &lt;&lt; endl;
        cout &lt;&lt; "s1的大小为： " &lt;&lt; s1.size() &lt;&lt; endl;
    }

}

//交换
void test02()
{
    set<int> s1;

    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);

    set<int> s2;

    s2.insert(100);
    s2.insert(300);
    s2.insert(200);
    s2.insert(400);

    cout &lt;&lt; "交换前" &lt;&lt; endl;
    printSet(s1);
    printSet(s2);
    cout &lt;&lt; endl;

    cout &lt;&lt; "交换后" &lt;&lt; endl;
    s1.swap(s2);
    printSet(s1);
    printSet(s2);
}

int main() {

    //test01();

    test02();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>统计大小   --- size</li>
<li>判断是否为空   --- empty</li>
<li>交换容器   --- swap</li>
</ul>
<h4 id="384-set-set">3.8.4 set插入和删除 <strong>功能描述：</strong> * set容器进行插入数据和删除数据<a class="headerlink" href="#384-set-set" title="Permanent link">&para;</a></h4>
<p><strong>函数原型：</strong> * <code>insert(elem);</code>           //在容器中插入元素。
* <code>clear();</code>                    //清除所有元素
* <code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
* <code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
* <code>erase(elem);</code>            //删除容器中值为elem的元素。</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_32">include <set><a class="headerlink" href="#include_32" title="Permanent link">&para;</a></h1>
<p>void printSet(set<int> &amp; s)
{
    for (set<int>::iterator it = s.begin(); it != s.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}</p>
<p>//插入和删除
void test01()
{
    set<int> s1;
    //插入
    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);
    printSet(s1);</p>
<div class="highlight"><pre><span></span><code>//删除
s1.erase(s1.begin());
printSet(s1);

s1.erase(30);
printSet(s1);

//清空
//s1.erase(s1.begin(), s1.end());
s1.clear();
printSet(s1);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* 插入   --- insert
* 删除   --- erase
* 清空   --- clear










</p>
<h4 id="385-set-set-findkey-keysetend">3.8.5 set查找和统计 <strong>功能描述：</strong> * 对set容器进行查找数据以及统计数据 <strong>函数原型：</strong> * <code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();<a class="headerlink" href="#385-set-set-findkey-keysetend" title="Permanent link">&para;</a></h4>
<ul>
<li><code>count(key);</code>                //统计key的元素个数



 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_33">include <set><a class="headerlink" href="#include_33" title="Permanent link">&para;</a></h1>
<p>//查找和统计
void test01()
{
    set<int> s1;
    //插入
    s1.insert(10);
    s1.insert(30);
    s1.insert(20);
    s1.insert(40);

    //查找
    set<int>::iterator pos = s1.find(30);

    if (pos != s1.end())
    {
        cout &lt;&lt; "找到了元素 ： " &lt;&lt; *pos &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "未找到元素" &lt;&lt; endl;
    }

    //统计
    int num = s1.count(30);
    cout &lt;&lt; "num = " &lt;&lt; num &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>查找   ---  find    （返回的是迭代器）</li>
<li>统计   ---  count  （对于set，结果为0或者1）</li>
</ul>
<h4 id="386-setmultiset-setmultiset-setmultiset">3.8.6 set和multiset区别 <strong>学习目标：</strong> * 掌握set和multiset的区别 <strong>区别：</strong> * set不可以插入重复数据，而multiset可以<a class="headerlink" href="#386-setmultiset-setmultiset-setmultiset" title="Permanent link">&para;</a></h4>
<ul>
<li>set插入数据的同时会返回插入结果，表示插入是否成功</li>
<li>multiset不会检测数据，因此可以插入重复数据</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_34">include <set><a class="headerlink" href="#include_34" title="Permanent link">&para;</a></h1>
<p>//set和multiset区别
void test01()
{
    set<int> s;
    pair<set\<int>::iterator, bool>  ret = s.insert(10);
    if (ret.second) {
        cout &lt;&lt; "第一次插入成功!" &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; "第一次插入失败!" &lt;&lt; endl;
    }</p>
<div class="highlight"><pre><span></span><code>ret = s.insert(10);
if (ret.second) {
    cout &lt;&lt; &quot;第二次插入成功!&quot; &lt;&lt; endl;
}
else {
    cout &lt;&lt; &quot;第二次插入失败!&quot; &lt;&lt; endl;
}

//multiset
multiset&lt;int&gt; ms;
ms.insert(10);
ms.insert(10);

for (multiset&lt;int&gt;::iterator it = ms.begin(); it != ms.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* 如果不允许插入重复数据可以利用set
* 如果需要插入重复数据利用multiset










</p>
<h4 id="387-pair-pairtype-type-p-value1-value2">3.8.7 pair对组创建 <strong>功能描述：</strong> * 成对出现的数据，利用对组可以返回两个数据 <strong>两种创建方式：</strong> * <code>pair&lt;type, type&gt; p ( value1, value2 );</code><a class="headerlink" href="#387-pair-pairtype-type-p-value1-value2" title="Permanent link">&para;</a></h4>
<ul>
<li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code>



 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_35">include <string><a class="headerlink" href="#include_35" title="Permanent link">&para;</a></h1>
<p>//对组创建
void test01()
{
    pair<string, int> p(string("Tom"), 20);
    cout &lt;&lt; "姓名： " &lt;&lt;  p.first &lt;&lt; " 年龄： " &lt;&lt; p.second &lt;&lt; endl;

    pair<string, int> p2 = make_pair("Jerry", 10);
    cout &lt;&lt; "姓名： " &lt;&lt; p2.first &lt;&lt; " 年龄： " &lt;&lt; p2.second &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<p>两种方式都可以创建对组，记住一种即可</p>
<h4 id="388-set">3.8.8 set容器排序<a class="headerlink" href="#388-set" title="Permanent link">&para;</a></h4>
<p>学习目标：</p>
<ul>
<li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li>
</ul>
<p>主要技术点：</p>
<ul>
<li>利用仿函数，可以改变排序规则 <strong>示例一</strong> set存放内置数据类型</li>
</ul>
<div class="highlight"><pre><span></span><code><a id="__codelineno-24-1" name="__codelineno-24-1" href="#__codelineno-24-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span>
<a id="__codelineno-24-2" name="__codelineno-24-2" href="#__codelineno-24-2"></a>
<a id="__codelineno-24-3" name="__codelineno-24-3" href="#__codelineno-24-3"></a><span class="k">class</span><span class="w"> </span><span class="nc">MyCompare</span><span class="w"> </span>
<a id="__codelineno-24-4" name="__codelineno-24-4" href="#__codelineno-24-4"></a><span class="p">{</span>
<a id="__codelineno-24-5" name="__codelineno-24-5" href="#__codelineno-24-5"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-24-6" name="__codelineno-24-6" href="#__codelineno-24-6"></a><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="w"> </span><span class="n">v1</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">v2</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-24-7" name="__codelineno-24-7" href="#__codelineno-24-7"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">v1</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">v2</span><span class="p">;</span>
<a id="__codelineno-24-8" name="__codelineno-24-8" href="#__codelineno-24-8"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-24-9" name="__codelineno-24-9" href="#__codelineno-24-9"></a><span class="p">};</span>
<a id="__codelineno-24-10" name="__codelineno-24-10" href="#__codelineno-24-10"></a><span class="kt">void</span><span class="w"> </span><span class="nf">test01</span><span class="p">()</span><span class="w"> </span>
<a id="__codelineno-24-11" name="__codelineno-24-11" href="#__codelineno-24-11"></a><span class="p">{</span><span class="w">    </span>
<a id="__codelineno-24-12" name="__codelineno-24-12" href="#__codelineno-24-12"></a><span class="w">    </span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s1</span><span class="p">;</span>
<a id="__codelineno-24-13" name="__codelineno-24-13" href="#__codelineno-24-13"></a><span class="w">    </span><span class="n">s1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-24-14" name="__codelineno-24-14" href="#__codelineno-24-14"></a><span class="w">    </span><span class="n">s1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
<a id="__codelineno-24-15" name="__codelineno-24-15" href="#__codelineno-24-15"></a><span class="w">    </span><span class="n">s1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<a id="__codelineno-24-16" name="__codelineno-24-16" href="#__codelineno-24-16"></a><span class="w">    </span><span class="n">s1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
<a id="__codelineno-24-17" name="__codelineno-24-17" href="#__codelineno-24-17"></a><span class="w">    </span><span class="n">s1</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<a id="__codelineno-24-18" name="__codelineno-24-18" href="#__codelineno-24-18"></a>
<a id="__codelineno-24-19" name="__codelineno-24-19" href="#__codelineno-24-19"></a><span class="w">    </span><span class="c1">//默认从小到大</span>
<a id="__codelineno-24-20" name="__codelineno-24-20" href="#__codelineno-24-20"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s1</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-24-21" name="__codelineno-24-21" href="#__codelineno-24-21"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-24-22" name="__codelineno-24-22" href="#__codelineno-24-22"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-24-23" name="__codelineno-24-23" href="#__codelineno-24-23"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-24-24" name="__codelineno-24-24" href="#__codelineno-24-24"></a>
<a id="__codelineno-24-25" name="__codelineno-24-25" href="#__codelineno-24-25"></a><span class="w">    </span><span class="c1">//指定排序规则</span>
<a id="__codelineno-24-26" name="__codelineno-24-26" href="#__codelineno-24-26"></a><span class="w">    </span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="n">MyCompare</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s2</span><span class="p">;</span>
<a id="__codelineno-24-27" name="__codelineno-24-27" href="#__codelineno-24-27"></a><span class="w">    </span><span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
<a id="__codelineno-24-28" name="__codelineno-24-28" href="#__codelineno-24-28"></a><span class="w">    </span><span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">40</span><span class="p">);</span>
<a id="__codelineno-24-29" name="__codelineno-24-29" href="#__codelineno-24-29"></a><span class="w">    </span><span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">20</span><span class="p">);</span>
<a id="__codelineno-24-30" name="__codelineno-24-30" href="#__codelineno-24-30"></a><span class="w">    </span><span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">30</span><span class="p">);</span>
<a id="__codelineno-24-31" name="__codelineno-24-31" href="#__codelineno-24-31"></a><span class="w">    </span><span class="n">s2</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">50</span><span class="p">);</span>
<a id="__codelineno-24-32" name="__codelineno-24-32" href="#__codelineno-24-32"></a>
<a id="__codelineno-24-33" name="__codelineno-24-33" href="#__codelineno-24-33"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span><span class="w"> </span><span class="n">MyCompare</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s2</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s2</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-24-34" name="__codelineno-24-34" href="#__codelineno-24-34"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="o">*</span><span class="n">it</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; &quot;</span><span class="p">;</span>
<a id="__codelineno-24-35" name="__codelineno-24-35" href="#__codelineno-24-35"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-24-36" name="__codelineno-24-36" href="#__codelineno-24-36"></a><span class="w">    </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-24-37" name="__codelineno-24-37" href="#__codelineno-24-37"></a><span class="p">}</span>
<a id="__codelineno-24-38" name="__codelineno-24-38" href="#__codelineno-24-38"></a>
<a id="__codelineno-24-39" name="__codelineno-24-39" href="#__codelineno-24-39"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-24-40" name="__codelineno-24-40" href="#__codelineno-24-40"></a>
<a id="__codelineno-24-41" name="__codelineno-24-41" href="#__codelineno-24-41"></a><span class="w">    </span><span class="n">test01</span><span class="p">();</span>
<a id="__codelineno-24-42" name="__codelineno-24-42" href="#__codelineno-24-42"></a>
<a id="__codelineno-24-43" name="__codelineno-24-43" href="#__codelineno-24-43"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-24-44" name="__codelineno-24-44" href="#__codelineno-24-44"></a>
<a id="__codelineno-24-45" name="__codelineno-24-45" href="#__codelineno-24-45"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-24-46" name="__codelineno-24-46" href="#__codelineno-24-46"></a><span class="p">}</span>
</code></pre></div>
<p>总结：利用仿函数可以指定set容器的排序规则 <strong>示例二</strong> set存放自定义数据类型</p>
<div class="highlight"><pre><span></span><code><a id="__codelineno-25-1" name="__codelineno-25-1" href="#__codelineno-25-1"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;set&gt;</span>
<a id="__codelineno-25-2" name="__codelineno-25-2" href="#__codelineno-25-2"></a><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;string&gt;</span>
<a id="__codelineno-25-3" name="__codelineno-25-3" href="#__codelineno-25-3"></a>
<a id="__codelineno-25-4" name="__codelineno-25-4" href="#__codelineno-25-4"></a><span class="k">class</span><span class="w"> </span><span class="nc">Person</span>
<a id="__codelineno-25-5" name="__codelineno-25-5" href="#__codelineno-25-5"></a><span class="p">{</span>
<a id="__codelineno-25-6" name="__codelineno-25-6" href="#__codelineno-25-6"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-25-7" name="__codelineno-25-7" href="#__codelineno-25-7"></a><span class="w">    </span><span class="n">Person</span><span class="p">(</span><span class="n">string</span><span class="w"> </span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">age</span><span class="p">)</span>
<a id="__codelineno-25-8" name="__codelineno-25-8" href="#__codelineno-25-8"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-25-9" name="__codelineno-25-9" href="#__codelineno-25-9"></a><span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Name</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">name</span><span class="p">;</span>
<a id="__codelineno-25-10" name="__codelineno-25-10" href="#__codelineno-25-10"></a><span class="w">        </span><span class="k">this</span><span class="o">-&gt;</span><span class="n">m_Age</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">age</span><span class="p">;</span>
<a id="__codelineno-25-11" name="__codelineno-25-11" href="#__codelineno-25-11"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-25-12" name="__codelineno-25-12" href="#__codelineno-25-12"></a>
<a id="__codelineno-25-13" name="__codelineno-25-13" href="#__codelineno-25-13"></a><span class="w">    </span><span class="n">string</span><span class="w"> </span><span class="n">m_Name</span><span class="p">;</span>
<a id="__codelineno-25-14" name="__codelineno-25-14" href="#__codelineno-25-14"></a><span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">m_Age</span><span class="p">;</span>
<a id="__codelineno-25-15" name="__codelineno-25-15" href="#__codelineno-25-15"></a>
<a id="__codelineno-25-16" name="__codelineno-25-16" href="#__codelineno-25-16"></a><span class="p">};</span>
<a id="__codelineno-25-17" name="__codelineno-25-17" href="#__codelineno-25-17"></a><span class="k">class</span><span class="w"> </span><span class="nc">comparePerson</span>
<a id="__codelineno-25-18" name="__codelineno-25-18" href="#__codelineno-25-18"></a><span class="p">{</span>
<a id="__codelineno-25-19" name="__codelineno-25-19" href="#__codelineno-25-19"></a><span class="k">public</span><span class="o">:</span>
<a id="__codelineno-25-20" name="__codelineno-25-20" href="#__codelineno-25-20"></a><span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="k">operator</span><span class="p">()(</span><span class="k">const</span><span class="w"> </span><span class="n">Person</span><span class="o">&amp;</span><span class="w"> </span><span class="n">p1</span><span class="p">,</span><span class="w"> </span><span class="k">const</span><span class="w"> </span><span class="n">Person</span><span class="w"> </span><span class="o">&amp;</span><span class="n">p2</span><span class="p">)</span>
<a id="__codelineno-25-21" name="__codelineno-25-21" href="#__codelineno-25-21"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-25-22" name="__codelineno-25-22" href="#__codelineno-25-22"></a><span class="w">        </span><span class="c1">//按照年龄进行排序  降序</span>
<a id="__codelineno-25-23" name="__codelineno-25-23" href="#__codelineno-25-23"></a><span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="n">p1</span><span class="p">.</span><span class="n">m_Age</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">p2</span><span class="p">.</span><span class="n">m_Age</span><span class="p">;</span>
<a id="__codelineno-25-24" name="__codelineno-25-24" href="#__codelineno-25-24"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-25-25" name="__codelineno-25-25" href="#__codelineno-25-25"></a><span class="p">};</span>
<a id="__codelineno-25-26" name="__codelineno-25-26" href="#__codelineno-25-26"></a>
<a id="__codelineno-25-27" name="__codelineno-25-27" href="#__codelineno-25-27"></a><span class="kt">void</span><span class="w"> </span><span class="nf">test01</span><span class="p">()</span>
<a id="__codelineno-25-28" name="__codelineno-25-28" href="#__codelineno-25-28"></a><span class="p">{</span>
<a id="__codelineno-25-29" name="__codelineno-25-29" href="#__codelineno-25-29"></a><span class="w">    </span><span class="n">set</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="w"> </span><span class="n">comparePerson</span><span class="o">&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">;</span>
<a id="__codelineno-25-30" name="__codelineno-25-30" href="#__codelineno-25-30"></a>
<a id="__codelineno-25-31" name="__codelineno-25-31" href="#__codelineno-25-31"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p1</span><span class="p">(</span><span class="s">&quot;刘备&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">23</span><span class="p">);</span>
<a id="__codelineno-25-32" name="__codelineno-25-32" href="#__codelineno-25-32"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p2</span><span class="p">(</span><span class="s">&quot;关羽&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">27</span><span class="p">);</span>
<a id="__codelineno-25-33" name="__codelineno-25-33" href="#__codelineno-25-33"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p3</span><span class="p">(</span><span class="s">&quot;张飞&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">25</span><span class="p">);</span>
<a id="__codelineno-25-34" name="__codelineno-25-34" href="#__codelineno-25-34"></a><span class="w">    </span><span class="n">Person</span><span class="w"> </span><span class="n">p4</span><span class="p">(</span><span class="s">&quot;赵云&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">21</span><span class="p">);</span>
<a id="__codelineno-25-35" name="__codelineno-25-35" href="#__codelineno-25-35"></a>
<a id="__codelineno-25-36" name="__codelineno-25-36" href="#__codelineno-25-36"></a><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p1</span><span class="p">);</span>
<a id="__codelineno-25-37" name="__codelineno-25-37" href="#__codelineno-25-37"></a><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>
<a id="__codelineno-25-38" name="__codelineno-25-38" href="#__codelineno-25-38"></a><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p3</span><span class="p">);</span>
<a id="__codelineno-25-39" name="__codelineno-25-39" href="#__codelineno-25-39"></a><span class="w">    </span><span class="n">s</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">p4</span><span class="p">);</span>
<a id="__codelineno-25-40" name="__codelineno-25-40" href="#__codelineno-25-40"></a>
<a id="__codelineno-25-41" name="__codelineno-25-41" href="#__codelineno-25-41"></a><span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">set</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="w"> </span><span class="n">comparePerson</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="w"> </span><span class="n">it</span><span class="o">++</span><span class="p">)</span>
<a id="__codelineno-25-42" name="__codelineno-25-42" href="#__codelineno-25-42"></a><span class="w">    </span><span class="p">{</span>
<a id="__codelineno-25-43" name="__codelineno-25-43" href="#__codelineno-25-43"></a><span class="w">        </span><span class="n">cout</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot;姓名： &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">m_Name</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="s">&quot; 年龄： &quot;</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">it</span><span class="o">-&gt;</span><span class="n">m_Age</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="n">endl</span><span class="p">;</span>
<a id="__codelineno-25-44" name="__codelineno-25-44" href="#__codelineno-25-44"></a><span class="w">    </span><span class="p">}</span>
<a id="__codelineno-25-45" name="__codelineno-25-45" href="#__codelineno-25-45"></a><span class="p">}</span>
<a id="__codelineno-25-46" name="__codelineno-25-46" href="#__codelineno-25-46"></a><span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<a id="__codelineno-25-47" name="__codelineno-25-47" href="#__codelineno-25-47"></a>
<a id="__codelineno-25-48" name="__codelineno-25-48" href="#__codelineno-25-48"></a><span class="w">    </span><span class="n">test01</span><span class="p">();</span>
<a id="__codelineno-25-49" name="__codelineno-25-49" href="#__codelineno-25-49"></a>
<a id="__codelineno-25-50" name="__codelineno-25-50" href="#__codelineno-25-50"></a><span class="w">    </span><span class="n">system</span><span class="p">(</span><span class="s">&quot;pause&quot;</span><span class="p">);</span>
<a id="__codelineno-25-51" name="__codelineno-25-51" href="#__codelineno-25-51"></a>
<a id="__codelineno-25-52" name="__codelineno-25-52" href="#__codelineno-25-52"></a><span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<a id="__codelineno-25-53" name="__codelineno-25-53" href="#__codelineno-25-53"></a><span class="p">}</span>
</code></pre></div>
<p>总结：</p>
<p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p>
<h3 id="39-map-multimap">3.9 map/ multimap容器<a class="headerlink" href="#39-map-multimap" title="Permanent link">&para;</a></h3>
<h4 id="391-map-mappair">3.9.1 map基本概念 <strong>简介：</strong> * map中所有元素都是pair<a class="headerlink" href="#391-map-mappair" title="Permanent link">&para;</a></h4>
<ul>
<li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li>
<li>所有元素都会根据元素的键值自动排序</li>
</ul>
<p><strong>本质：</strong> * map/multimap属于 <strong>关联式容器</strong> ，底层结构是用二叉树实现。 <strong>优点：</strong> * 可以根据key值快速找到value值</p>
<p>map和multimap <strong>区别</strong> ：</p>
<ul>
<li>map不允许容器中有重复key值元素</li>
<li>multimap允许容器中有重复key值元素</li>
</ul>
<h4 id="392-map-map-mapt1-t2-mp-map">3.9.2  map构造和赋值 <strong>功能描述：</strong> * 对map容器进行构造和赋值操作 <strong>函数原型：</strong>  <strong>构造：</strong> * <code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数:<a class="headerlink" href="#392-map-map-mapt1-t2-mp-map" title="Permanent link">&para;</a></h4>
<ul>
<li><code>map(const map &amp;mp);</code>             //拷贝构造函数 <strong>赋值：</strong> * <code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li>
</ul>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_36">include <map><a class="headerlink" href="#include_36" title="Permanent link">&para;</a></h1>
<p>void printMap(map<int,int>&amp;m)
{
    for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
    {
        cout &lt;&lt; "key = " &lt;&lt; it-&gt;first &lt;&lt; " value = " &lt;&lt; it-&gt;second &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}</p>
<p>void test01()
{
    map<int,int>m; //默认构造
    m.insert(pair<int, int>(1, 10));
    m.insert(pair<int, int>(2, 20));
    m.insert(pair<int, int>(3, 30));
    printMap(m);</p>
<div class="highlight"><pre><span></span><code>map&lt;int, int&gt;m2(m); //拷贝构造
printMap(m2);

map&lt;int, int&gt;m3;
m3 = m2; //赋值
printMap(m3);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：map中所有元素都是成对出现，插入数据时候要使用对组










</p>
<h4 id="393-map-mapmap">3.9.3 map大小和交换 <strong>功能描述：</strong> * 统计map容器大小以及交换map容器<a class="headerlink" href="#393-map-mapmap" title="Permanent link">&para;</a></h4>
<p>函数原型：

- <code>size();</code>          //返回容器中元素的数目
- <code>empty();</code>        //判断容器是否为空
- <code>swap(st);</code>      //交换两个集合容器



 <strong>示例：</strong> ```C++</p>
<h1 id="include_37">include <map><a class="headerlink" href="#include_37" title="Permanent link">&para;</a></h1>
<p>void printMap(map<int,int>&amp;m)
{
    for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
    {
        cout &lt;&lt; "key = " &lt;&lt; it-&gt;first &lt;&lt; " value = " &lt;&lt; it-&gt;second &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}

void test01()
{
    map<int, int>m;
    m.insert(pair<int, int>(1, 10));
    m.insert(pair<int, int>(2, 20));
    m.insert(pair<int, int>(3, 30));

    if (m.empty())
    {
        cout &lt;&lt; "m为空" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "m不为空" &lt;&lt; endl;
        cout &lt;&lt; "m的大小为： " &lt;&lt; m.size() &lt;&lt; endl;
    }
}


//交换
void test02()
{
    map<int, int>m;
    m.insert(pair<int, int>(1, 10));
    m.insert(pair<int, int>(2, 20));
    m.insert(pair<int, int>(3, 30));

    map<int, int>m2;
    m2.insert(pair<int, int>(4, 100));
    m2.insert(pair<int, int>(5, 200));
    m2.insert(pair<int, int>(6, 300));

    cout &lt;&lt; "交换前" &lt;&lt; endl;
    printMap(m);
    printMap(m2);

    cout &lt;&lt; "交换后" &lt;&lt; endl;
    m.swap(m2);
    printMap(m);
    printMap(m2);
}

int main() {

    test01();

    test02();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>统计大小   --- size</li>
<li>判断是否为空   --- empty</li>
<li>交换容器   --- swap</li>
</ul>
<h4 id="394-map-map">3.9.4 map插入和删除 <strong>功能描述：</strong> - map容器进行插入数据和删除数据<a class="headerlink" href="#394-map-map" title="Permanent link">&para;</a></h4>
<p><strong>函数原型：</strong> - <code>insert(elem);</code>           //在容器中插入元素。
- <code>clear();</code>                    //清除所有元素
- <code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。
- <code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。
- <code>erase(key);</code>            //删除容器中值为key的元素。</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_38">include <map><a class="headerlink" href="#include_38" title="Permanent link">&para;</a></h1>
<p>void printMap(map<int,int>&amp;m)
{
    for (map<int, int>::iterator it = m.begin(); it != m.end(); it++)
    {
        cout &lt;&lt; "key = " &lt;&lt; it-&gt;first &lt;&lt; " value = " &lt;&lt; it-&gt;second &lt;&lt; endl;
    }
    cout &lt;&lt; endl;
}</p>
<p>void test01()
{
    //插入
    map<int, int> m;
    //第一种插入方式
    m.insert(pair<int, int>(1, 10));
    //第二种插入方式
    m.insert(make_pair(2, 20));
    //第三种插入方式
    m.insert(map<int, int>::value_type(3, 30));
    //第四种插入方式
    m[4] = 40; 
    printMap(m);</p>
<div class="highlight"><pre><span></span><code>//删除
m.erase(m.begin());
printMap(m);

m.erase(3);
printMap(m);

//清空
m.erase(m.begin(),m.end());
m.clear();
printMap(m);
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* map插入方式很多，记住其一即可

- 插入   --- insert 
- 删除   --- erase
- 清空   --- clear












</p>
<h4 id="395-map-map-findkey-keysetend">3.9.5 map查找和统计 <strong>功能描述：</strong> - 对map容器进行查找数据以及统计数据 <strong>函数原型：</strong> - <code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();<a class="headerlink" href="#395-map-map-findkey-keysetend" title="Permanent link">&para;</a></h4>
<ul>
<li><code>count(key);</code>                //统计key的元素个数

 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_39">include <map><a class="headerlink" href="#include_39" title="Permanent link">&para;</a></h1>
<p>//查找和统计
void test01()
{
    map<int, int>m; 
    m.insert(pair<int, int>(1, 10));
    m.insert(pair<int, int>(2, 20));
    m.insert(pair<int, int>(3, 30));

    //查找
    map<int, int>::iterator pos = m.find(3);

    if (pos != m.end())
    {
        cout &lt;&lt; "找到了元素 key = " &lt;&lt; (*pos).first &lt;&lt; " value = " &lt;&lt; (*pos).second &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "未找到元素" &lt;&lt; endl;
    }

    //统计
    int num = m.count(3);
    cout &lt;&lt; "num = " &lt;&lt; num &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>查找   ---  find    （返回的是迭代器）</li>
<li>统计   ---  count  （对于map，结果为0或者1）</li>
</ul>
<h4 id="396-map-map-key-">3.9.6 map容器排序 <strong>学习目标：</strong> - map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则 <strong>主要技术点:</strong> - 利用仿函数，可以改变排序规则<a class="headerlink" href="#396-map-map-key-" title="Permanent link">&para;</a></h4>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_40">include <map><a class="headerlink" href="#include_40" title="Permanent link">&para;</a></h1>
<p>class MyCompare {
public:
    bool operator()(int v1, int v2) {
        return v1 &gt; v2;
    }
};</p>
<p>void test01() 
{
    //默认从小到大排序
    //利用仿函数实现从大到小排序
    map<int, int, MyCompare> m;</p>
<div class="highlight"><pre><span></span><code>m.insert(make_pair(1, 10));
m.insert(make_pair(2, 20));
m.insert(make_pair(3, 30));
m.insert(make_pair(4, 40));
m.insert(make_pair(5, 50));

for (map&lt;int, int, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) {
    cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
}
</code></pre></div>
<p>}
int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* 利用仿函数可以指定map容器的排序规则
* 对于自定义数据类型，map必须要指定排序规则,同set容器












</p>
<h3 id="310-">3.10 案例-员工分组<a class="headerlink" href="#310-" title="Permanent link">&para;</a></h3>
<h4 id="3101">3.10.1 案例描述<a class="headerlink" href="#3101" title="Permanent link">&para;</a></h4>
<ul>
<li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li>
<li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li>
<li>随机给10名员工分配部门和工资</li>
<li>通过multimap进行信息的插入  key(部门编号) value(员工)</li>
<li>分部门显示员工信息




</li>
</ul>
<h4 id="3102">3.10.2 实现步骤<a class="headerlink" href="#3102" title="Permanent link">&para;</a></h4>
<ol>
<li>创建10名员工，放到vector中</li>
<li>遍历vector容器，取出每个员工，进行随机分组</li>
<li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li>
<li>分部门显示员工信息 <strong>案例代码：</strong> ```C++</li>
</ol>
<h1 id="include_41">include<iostream><a class="headerlink" href="#include_41" title="Permanent link">&para;</a></h1>
<p>using namespace std;</p>
<h1 id="include_42">include <vector><a class="headerlink" href="#include_42" title="Permanent link">&para;</a></h1>
<h1 id="include_43">include <string><a class="headerlink" href="#include_43" title="Permanent link">&para;</a></h1>
<h1 id="include_44">include <map><a class="headerlink" href="#include_44" title="Permanent link">&para;</a></h1>
<h1 id="include_45">include <ctime><a class="headerlink" href="#include_45" title="Permanent link">&para;</a></h1>
<p>/*
- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作
- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发
- 随机给10名员工分配部门和工资
- 通过multimap进行信息的插入  key(部门编号) value(员工)
- 分部门显示员工信息
*/
</p>
<h1 id="define-cehua-0">define CEHUA  0<a class="headerlink" href="#define-cehua-0" title="Permanent link">&para;</a></h1>
<h1 id="define-meishu-1">define MEISHU 1<a class="headerlink" href="#define-meishu-1" title="Permanent link">&para;</a></h1>
<h1 id="define-yanfa-2">define YANFA  2<a class="headerlink" href="#define-yanfa-2" title="Permanent link">&para;</a></h1>
<p>class Worker
{
public:
    string m_Name;
    int m_Salary;
};

void createWorker(vector<Worker>&amp;v)
{
    string nameSeed = "ABCDEFGHIJ";
    for (int i = 0; i &lt; 10; i++)
    {
        Worker worker;
        worker.m_Name = "员工";
        worker.m_Name += nameSeed[i];

        worker.m_Salary = rand() % 10000 + 10000; // 10000 ~ 19999
        //将员工放入到容器中
        v.push_back(worker);
    }
}

//员工分组
void setGroup(vector<Worker>&amp;v,multimap<int,Worker>&amp;m)
{
    for (vector<Worker>::iterator it = v.begin(); it != v.end(); it++)
    {
        //产生随机部门编号
        int deptId = rand() % 3; // 0 1 2 

        //将员工插入到分组中
        //key部门编号，value具体员工
        m.insert(make_pair(deptId, *it));
    }
}

void showWorkerByGourp(multimap<int,Worker>&amp;m)
{
    // 0  A  B  C   1  D  E   2  F G ...
    cout &lt;&lt; "策划部门：" &lt;&lt; endl;

    multimap<int,Worker>::iterator pos = m.find(CEHUA);
    int count = m.count(CEHUA); // 统计具体人数
    int index = 0;
    for (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)
    {
        cout &lt;&lt; "姓名： " &lt;&lt; pos-&gt;second.m_Name &lt;&lt; " 工资： " &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
    }

    cout &lt;&lt; "----------------------" &lt;&lt; endl;
    cout &lt;&lt; "美术部门： " &lt;&lt; endl;
    pos = m.find(MEISHU);
    count = m.count(MEISHU); // 统计具体人数
    index = 0;
    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)
    {
        cout &lt;&lt; "姓名： " &lt;&lt; pos-&gt;second.m_Name &lt;&lt; " 工资： " &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
    }

    cout &lt;&lt; "----------------------" &lt;&lt; endl;
    cout &lt;&lt; "研发部门： " &lt;&lt; endl;
    pos = m.find(YANFA);
    count = m.count(YANFA); // 统计具体人数
    index = 0;
    for (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)
    {
        cout &lt;&lt; "姓名： " &lt;&lt; pos-&gt;second.m_Name &lt;&lt; " 工资： " &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; endl;
    }

}

int main() {

    srand((unsigned int)time(NULL));

    //1、创建员工
    vector<Worker>vWorker;
    createWorker(vWorker);

    //2、员工分组
    multimap<int, Worker>mWorker;
    setGroup(vWorker, mWorker);


    //3、分组显示员工
    showWorkerByGourp(mWorker);

    ////测试
    //for (vector<Worker>::iterator it = vWorker.begin(); it != vWorker.end(); it++)
    //{
    //  cout &lt;&lt; "姓名： " &lt;&lt; it-&gt;m_Name &lt;&lt; " 工资： " &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;
    //}

    system("pause");

    return 0;
}
```</p>
<p>总结：</p>
<ul>
<li>当数据以键值对形式存在，可以考虑用map 或 multimap</li>
</ul>
<h2 id="4-stl-">4 STL- 函数对象<a class="headerlink" href="#4-stl-" title="Permanent link">&para;</a></h2>
<h3 id="41">4.1 函数对象<a class="headerlink" href="#41" title="Permanent link">&para;</a></h3>
<h4 id="411">4.1.1 函数对象概念 <strong>概念：</strong> * 重载 <strong>函数调用操作符</strong> 的类，其对象常称为 <strong>函数对象</strong> * <strong>函数对象</strong> 使用重载的()时，行为类似函数调用，也叫 <strong>仿函数</strong><a class="headerlink" href="#411" title="Permanent link">&para;</a></h4>
<p><strong>本质：</strong> 函数对象(仿函数)是一个 <strong>类</strong> ，不是一个函数</p>
<h4 id="412">4.1.2  函数对象使用 <strong>特点：</strong> * 函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值<a class="headerlink" href="#412" title="Permanent link">&para;</a></h4>
<ul>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
<li>函数对象可以作为参数传递 <strong>示例:</strong> ```C++</li>
</ul>
<h1 id="include_46">include <string><a class="headerlink" href="#include_46" title="Permanent link">&para;</a></h1>
<p>//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值
class MyAdd
{
public :
    int operator()(int v1,int v2)
    {
        return v1 + v2;
    }
};</p>
<p>void test01()
{
    MyAdd myAdd;
    cout &lt;&lt; myAdd(10, 10) &lt;&lt; endl;
}</p>
<p>//2、函数对象可以有自己的状态
class MyPrint
{
public:
    MyPrint()
    {
        count = 0;
    }
    void operator()(string test)
    {
        cout &lt;&lt; test &lt;&lt; endl;
        count++; //统计使用次数
    }</p>
<div class="highlight"><pre><span></span><code>int count; //内部自己的状态
</code></pre></div>
<p>};
void test02()
{
    MyPrint myPrint;
    myPrint("hello world");
    myPrint("hello world");
    myPrint("hello world");
    cout &lt;&lt; "myPrint调用次数为： " &lt;&lt; myPrint.count &lt;&lt; endl;
}</p>
<p>//3、函数对象可以作为参数传递
void doPrint(MyPrint &amp;mp , string test)
{
    mp(test);
}</p>
<p>void test03()
{
    MyPrint myPrint;
    doPrint(myPrint, "Hello C++");
}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>//test01();
//test02();
test03();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：

* 仿函数写法非常灵活，可以作为参数进行传递。
</p>
<h3 id="42">4.2  谓词<a class="headerlink" href="#42" title="Permanent link">&para;</a></h3>
<h4 id="421-bool-operator">4.2.1 谓词概念 <strong>概念：</strong> * 返回bool类型的仿函数称为 <strong>谓词</strong> * 如果operator()接受一个参数，那么叫做一元谓词<a class="headerlink" href="#421-bool-operator" title="Permanent link">&para;</a></h4>
<ul>
<li>如果operator()接受两个参数，那么叫做二元谓词
</li>
</ul>
<h4 id="422-c">4.2.2 一元谓词 <strong>示例：</strong> ```C++<a class="headerlink" href="#422-c" title="Permanent link">&para;</a></h4>
<h1 id="include_47">include <vector><a class="headerlink" href="#include_47" title="Permanent link">&para;</a></h1>
<h1 id="include_48">include <algorithm><a class="headerlink" href="#include_48" title="Permanent link">&para;</a></h1>
<p>//1.一元谓词
struct GreaterFive{
    bool operator()(int val) {
        return val &gt; 5;
    }
};

void test01() {

    vector<int> v;
    for (int i = 0; i &lt; 10; i++)
    {
        v.push_back(i);
    }

    vector<int>::iterator it = find_if(v.begin(), v.end(), GreaterFive());
    if (it == v.end()) {
        cout &lt;&lt; "没找到!" &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; "找到:" &lt;&lt; *it &lt;&lt; endl;
    }

}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：参数只有一个的谓词，称为一元谓词</p>
<h4 id="423-c">4.2.3 二元谓词 <strong>示例：</strong> ```C++<a class="headerlink" href="#423-c" title="Permanent link">&para;</a></h4>
<h1 id="include_49">include <vector><a class="headerlink" href="#include_49" title="Permanent link">&para;</a></h1>
<h1 id="include_50">include <algorithm><a class="headerlink" href="#include_50" title="Permanent link">&para;</a></h1>
<p>//二元谓词
class MyCompare
{
public:
    bool operator()(int num1, int num2)
    {
        return num1 &gt; num2;
    }
};</p>
<p>void test01()
{
    vector<int> v;
    v.push_back(10);
    v.push_back(40);
    v.push_back(20);
    v.push_back(30);
    v.push_back(50);</p>
<div class="highlight"><pre><span></span><code>//默认从小到大
sort(v.begin(), v.end());
for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
{
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
cout &lt;&lt; &quot;----------------------------&quot; &lt;&lt; endl;

//使用函数对象改变算法策略，排序从大到小
sort(v.begin(), v.end(), MyCompare());
for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++)
{
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：参数只有两个的谓词，称为二元谓词
</p>
<h3 id="43">4.3 内建函数对象<a class="headerlink" href="#43" title="Permanent link">&para;</a></h3>
<h4 id="431-stl">4.3.1 内建函数对象意义 <strong>概念：</strong> * STL内建了一些函数对象 <strong>分类:</strong> * 算术仿函数<a class="headerlink" href="#431-stl" title="Permanent link">&para;</a></h4>
<ul>
<li>关系仿函数
</li>
<li>逻辑仿函数 <strong>用法：</strong> * 这些仿函数所产生的对象，用法和一般函数完全相同</li>
<li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code>
</li>
</ul>
<h4 id="432">4.3.2 算术仿函数 <strong>功能描述：</strong> * 实现四则运算<a class="headerlink" href="#432" title="Permanent link">&para;</a></h4>
<ul>
<li>其中negate是一元运算，其他都是二元运算 <strong>仿函数原型：</strong> * <code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li>
<li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li>
<li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li>
<li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li>
<li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li>
<li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_51">include <functional><a class="headerlink" href="#include_51" title="Permanent link">&para;</a></h1>
<p>//negate
void test01()
{
    negate<int> n;
    cout &lt;&lt; n(50) &lt;&lt; endl;
}

//plus
void test02()
{
    plus<int> p;
    cout &lt;&lt; p(10, 20) &lt;&lt; endl;
}

int main() {

    test01();
    test02();

    system("pause");

    return 0;
}
```</p>
<p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code>。</p>
<h4 id="433-templateclass-t-bool-equal_tot">4.3.3 关系仿函数 <strong>功能描述：</strong> - 实现关系对比 <strong>仿函数原型：</strong> * <code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于<a class="headerlink" href="#433-templateclass-t-bool-equal_tot" title="Permanent link">&para;</a></h4>
<ul>
<li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li>
<li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li>
<li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li>
<li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li>
<li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_52">include <functional><a class="headerlink" href="#include_52" title="Permanent link">&para;</a></h1>
<h1 id="include_53">include <vector><a class="headerlink" href="#include_53" title="Permanent link">&para;</a></h1>
<h1 id="include_54">include <algorithm><a class="headerlink" href="#include_54" title="Permanent link">&para;</a></h1>
<p>class MyCompare
{
public:
    bool operator()(int v1,int v2)
    {
        return v1 &gt; v2;
    }
};
void test01()
{
    vector<int> v;</p>
<div class="highlight"><pre><span></span><code>v.push_back(10);
v.push_back(30);
v.push_back(50);
v.push_back(40);
v.push_back(20);

for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;

//自己实现仿函数
//sort(v.begin(), v.end(), MyCompare());
//STL内建仿函数  大于仿函数
sort(v.begin(), v.end(), greater&lt;int&gt;());

for (vector&lt;int&gt;::iterator it = v.begin(); it != v.end(); it++) {
    cout &lt;&lt; *it &lt;&lt; &quot; &quot;;
}
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
```

总结：关系仿函数中最常用的就是greater&lt;&gt;大于
</p>
<h4 id="434-templateclass-t-bool-logical_andt">4.3.4 逻辑仿函数 <strong>功能描述：</strong> - 实现逻辑运算 <strong>函数原型：</strong> * <code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与<a class="headerlink" href="#434-templateclass-t-bool-logical_andt" title="Permanent link">&para;</a></h4>
<ul>
<li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li>
<li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_55">include <vector><a class="headerlink" href="#include_55" title="Permanent link">&para;</a></h1>
<h1 id="include_56">include <functional><a class="headerlink" href="#include_56" title="Permanent link">&para;</a></h1>
<h1 id="include_57">include <algorithm><a class="headerlink" href="#include_57" title="Permanent link">&para;</a></h1>
<p>void test01()
{
    vector<bool> v;
    v.push_back(true);
    v.push_back(false);
    v.push_back(true);
    v.push_back(false);

    for (vector<bool>::iterator it = v.begin();it!= v.end();it++)
    {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;

    //逻辑非  将v容器搬运到v2中，并执行逻辑非运算
    vector<bool> v2;
    v2.resize(v.size());
    transform(v.begin(), v.end(),  v2.begin(), logical_not<bool>());
    for (vector<bool>::iterator it = v2.begin(); it != v2.end(); it++)
    {
        cout &lt;&lt; *it &lt;&lt; " ";
    }
    cout &lt;&lt; endl;
}

int main() {

    test01();

    system("pause");

    return 0;
}
```</p>
<p>总结：逻辑仿函数实际应用较少，了解即可</p>
<hr />
<h2 id="5-stl-">5 STL- 常用算法 <strong>概述</strong> :<a class="headerlink" href="#5-stl-" title="Permanent link">&para;</a></h2>
<ul>
<li>
<p>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</p>
</li>
<li>
<p><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</p>
</li>
<li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li>
<li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li>
</ul>
<h3 id="51-for_each">5.1 常用遍历算法 <strong>学习目标：</strong> * 掌握常用的遍历算法 <strong>算法简介：</strong> * <code>for_each</code>     //遍历容器<a class="headerlink" href="#51-for_each" title="Permanent link">&para;</a></h3>
<ul>
<li><code>transform</code>   //搬运容器到另一个容器中</li>
</ul>
<h4 id="511-for_each-for_eachiterator-beg-iterator-end-_func">5.1.1 for_each <strong>功能描述：</strong> * 实现遍历容器 <strong>函数原型：</strong> * <code>for_each(iterator beg, iterator end, _func);</code><a class="headerlink" href="#511-for_each-for_eachiterator-beg-iterator-end-_func" title="Permanent link">&para;</a></h4>
<p>// 遍历算法 遍历容器元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _func 函数或者函数对象 <strong>示例：</strong> ```C++</p>
<h1 id="include_58">include <algorithm><a class="headerlink" href="#include_58" title="Permanent link">&para;</a></h1>
<h1 id="include_59">include <vector><a class="headerlink" href="#include_59" title="Permanent link">&para;</a></h1>
<p>//普通函数
void print01(int val) 
{
    cout &lt;&lt; val &lt;&lt; " ";
}
//函数对象
class print02 
{
 public:
    void operator()(int val) 
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>//for_each算法基本用法
void test01() {</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt; v;
for (int i = 0; i &lt; 10; i++) 
{
    v.push_back(i);
}

//遍历算法
for_each(v.begin(), v.end(), print01);
cout &lt;&lt; endl;

for_each(v.begin(), v.end(), print02());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> for_each在实际开发中是最常用遍历算法，需要熟练掌握。</p>
<h4 id="512-transform-transformiterator-beg1-iterator-end1-iterator-beg2-_func">5.1.2 transform <strong>功能描述：</strong> * 搬运容器到另一个容器中 <strong>函数原型：</strong> * <code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code><a class="headerlink" href="#512-transform-transformiterator-beg1-iterator-end1-iterator-beg2-_func" title="Permanent link">&para;</a></h4>
<ul>
<li>beg1 源容器开始迭代器</li>
<li>end1 源容器结束迭代器</li>
<li>beg2 目标容器开始迭代器</li>
<li>_func 函数或者函数对象 <strong>示例：</strong> ```C++</li>
</ul>
<h1 id="include_60">include<vector><a class="headerlink" href="#include_60" title="Permanent link">&para;</a></h1>
<h1 id="include_61">include<algorithm><a class="headerlink" href="#include_61" title="Permanent link">&para;</a></h1>
<p>//常用遍历算法  搬运 transform</p>
<p>class TransForm
{
public:
    int operator()(int val)
    {
        return val;
    }</p>
<p>};</p>
<p>class MyPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int>v;
    for (int i = 0; i &lt; 10; i++)
    {
        v.push_back(i);
    }</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt;vTarget; //目标容器

vTarget.resize(v.size()); // 目标容器需要提前开辟空间

transform(v.begin(), v.end(), vTarget.begin(), TransForm());

for_each(vTarget.begin(), vTarget.end(), MyPrint());
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运。</p>
<h3 id="52">5.2 常用查找算法<a class="headerlink" href="#52" title="Permanent link">&para;</a></h3>
<p>学习目标：</p>
<ul>
<li>掌握常用的查找算法 <strong>算法简介：</strong> - <code>find</code>                     //查找元素</li>
<li><code>find_if</code>               //按条件查找元素</li>
<li><code>adjacent_find</code>    //查找相邻重复元素</li>
<li><code>binary_search</code>    //二分查找法</li>
<li><code>count</code>                   //统计元素个数</li>
<li><code>count_if</code>             //按条件统计元素个数</li>
</ul>
<h4 id="521-find-end-finditerator-beg-iterator-end-value">5.2.1 find <strong>功能描述：</strong> * 查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end() <strong>函数原型：</strong> - <code>find(iterator beg, iterator end, value);</code><a class="headerlink" href="#521-find-end-finditerator-beg-iterator-end-value" title="Permanent link">&para;</a></h4>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素 <strong>示例：</strong> ```C++</p>
<h1 id="include_62">include <algorithm><a class="headerlink" href="#include_62" title="Permanent link">&para;</a></h1>
<h1 id="include_63">include <vector><a class="headerlink" href="#include_63" title="Permanent link">&para;</a></h1>
<h1 id="include_64">include <string><a class="headerlink" href="#include_64" title="Permanent link">&para;</a></h1>
<p>void test01() {</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt; v;
for (int i = 0; i &lt; 10; i++) {
    v.push_back(i + 1);
}
//查找容器中是否有 5 这个元素
vector&lt;int&gt;::iterator it = find(v.begin(), v.end(), 5);
if (it == v.end()) 
{
    cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
}
else 
{
    cout &lt;&lt; &quot;找到:&quot; &lt;&lt; *it &lt;&lt; endl;
}
</code></pre></div>
<p>}</p>
<p>class Person {
public:
    Person(string name, int age) 
    {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }
    //重载==
    bool operator==(const Person&amp; p) 
    {
        if (this-&gt;m_Name == p.m_Name &amp;&amp; this-&gt;m_Age == p.m_Age) 
        {
            return true;
        }
        return false;
    }</p>
<p>public:
    string m_Name;
    int m_Age;
};</p>
<p>void test02() {</p>
<div class="highlight"><pre><span></span><code>vector&lt;Person&gt; v;

//创建数据
Person p1(&quot;aaa&quot;, 10);
Person p2(&quot;bbb&quot;, 20);
Person p3(&quot;ccc&quot;, 30);
Person p4(&quot;ddd&quot;, 40);

v.push_back(p1);
v.push_back(p2);
v.push_back(p3);
v.push_back(p4);

vector&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);
if (it == v.end()) 
{
    cout &lt;&lt; &quot;没有找到!&quot; &lt;&lt; endl;
}
else 
{
    cout &lt;&lt; &quot;找到姓名:&quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 年龄: &quot; &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
}
</code></pre></div>
<p>}
```

总结： 利用find可以在容器中找指定的元素，返回值是 <strong>迭代器</strong> 












</p>
<h4 id="522-find_if-find_ifiterator-beg-iterator-end-_pred">5.2.2 find_if <strong>功能描述：</strong> * 按条件查找元素 <strong>函数原型：</strong> - <code>find_if(iterator beg, iterator end, _Pred);</code><a class="headerlink" href="#522-find_if-find_ifiterator-beg-iterator-end-_pred" title="Permanent link">&para;</a></h4>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置

  // beg 开始迭代器

  // end 结束迭代器

  // _Pred 函数或者谓词（返回bool类型的仿函数）

 <strong>示例：</strong> ```C++</p>
<h1 id="include_65">include <algorithm><a class="headerlink" href="#include_65" title="Permanent link">&para;</a></h1>
<h1 id="include_66">include <vector><a class="headerlink" href="#include_66" title="Permanent link">&para;</a></h1>
<h1 id="include_67">include <string><a class="headerlink" href="#include_67" title="Permanent link">&para;</a></h1>
<p>//内置数据类型
class GreaterFive
{
public:
    bool operator()(int val)
    {
        return val &gt; 5;
    }
};

void test01() {

    vector<int> v;
    for (int i = 0; i &lt; 10; i++) {
        v.push_back(i + 1);
    }

    vector<int>::iterator it = find_if(v.begin(), v.end(), GreaterFive());
    if (it == v.end()) {
        cout &lt;&lt; "没有找到!" &lt;&lt; endl;
    }
    else {
        cout &lt;&lt; "找到大于5的数字:" &lt;&lt; *it &lt;&lt; endl;
    }
}

//自定义数据类型
class Person {
public:
    Person(string name, int age)
    {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }
public:
    string m_Name;
    int m_Age;
};

class Greater20
{
public:
    bool operator()(Person &amp;p)
    {
        return p.m_Age &gt; 20;
    }

};

void test02() {

    vector<Person> v;

    //创建数据
    Person p1("aaa", 10);
    Person p2("bbb", 20);
    Person p3("ccc", 30);
    Person p4("ddd", 40);

    v.push_back(p1);
    v.push_back(p2);
    v.push_back(p3);
    v.push_back(p4);

    vector<Person>::iterator it = find_if(v.begin(), v.end(), Greater20());
    if (it == v.end())
    {
        cout &lt;&lt; "没有找到!" &lt;&lt; endl;
    }
    else
    {
        cout &lt;&lt; "找到姓名:" &lt;&lt; it-&gt;m_Name &lt;&lt; " 年龄: " &lt;&lt; it-&gt;m_Age &lt;&lt; endl;
    }
}

int main() {

    //test01();

    test02();

    system("pause");

    return 0;
}
```</p>
<p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p>
<h4 id="523-adjacent_find-adjacent_finditerator-beg-iterator-end">5.2.3 adjacent_find <strong>功能描述：</strong> * 查找相邻重复元素 <strong>函数原型：</strong> - <code>adjacent_find(iterator beg, iterator end);</code><a class="headerlink" href="#523-adjacent_find-adjacent_finditerator-beg-iterator-end" title="Permanent link">&para;</a></h4>
<p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_68">include <algorithm><a class="headerlink" href="#include_68" title="Permanent link">&para;</a></h1>
<h1 id="include_69">include <vector><a class="headerlink" href="#include_69" title="Permanent link">&para;</a></h1>
<p>void test01()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(5);
    v.push_back(2);
    v.push_back(4);
    v.push_back(4);
    v.push_back(3);</p>
<div class="highlight"><pre><span></span><code>//查找相邻重复元素
vector&lt;int&gt;::iterator it = adjacent_find(v.begin(), v.end());
if (it == v.end()) {
    cout &lt;&lt; &quot;找不到!&quot; &lt;&lt; endl;
}
else {
    cout &lt;&lt; &quot;找到相邻重复元素为:&quot; &lt;&lt; *it &lt;&lt; endl;
}
</code></pre></div>
<p>}
```</p>
<p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p>
<h4 id="524-binary_search-bool-binary_searchiterator-beg-iterator-end-value">5.2.4 binary_search <strong>功能描述：</strong> * 查找指定元素是否存在 <strong>函数原型：</strong> - <code>bool binary_search(iterator beg, iterator end, value);</code><a class="headerlink" href="#524-binary_search-bool-binary_searchiterator-beg-iterator-end-value" title="Permanent link">&para;</a></h4>
<p>// 查找指定的元素，查到 返回true  否则false</p>
<p>// 注意: 在 <strong>无序序列中不可用</strong> // beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 查找的元素</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_70">include <algorithm><a class="headerlink" href="#include_70" title="Permanent link">&para;</a></h1>
<h1 id="include_71">include <vector><a class="headerlink" href="#include_71" title="Permanent link">&para;</a></h1>
<p>void test01()
{
    vector<int>v;</p>
<div class="highlight"><pre><span></span><code>for (int i = 0; i &lt; 10; i++)
{
    v.push_back(i);
}
//二分查找
bool ret = binary_search(v.begin(), v.end(),2);
if (ret)
{
    cout &lt;&lt; &quot;找到了&quot; &lt;&lt; endl;
}
else
{
    cout &lt;&lt; &quot;未找到&quot; &lt;&lt; endl;
}
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> 二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p>
<h4 id="525-count-countiterator-beg-iterator-end-value">5.2.5 count <strong>功能描述：</strong> * 统计元素个数 <strong>函数原型：</strong> - <code>count(iterator beg, iterator end, value);</code><a class="headerlink" href="#525-count-countiterator-beg-iterator-end-value" title="Permanent link">&para;</a></h4>
<p>// 统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 统计的元素</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_72">include <algorithm><a class="headerlink" href="#include_72" title="Permanent link">&para;</a></h1>
<h1 id="include_73">include <vector><a class="headerlink" href="#include_73" title="Permanent link">&para;</a></h1>
<p>//内置数据类型
void test01()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(4);
    v.push_back(5);
    v.push_back(3);
    v.push_back(4);
    v.push_back(4);</p>
<div class="highlight"><pre><span></span><code>int num = count(v.begin(), v.end(), 4);

cout &lt;&lt; &quot;4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>//自定义数据类型
class Person
{
public:
    Person(string name, int age)
    {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }
    bool operator==(const Person &amp; p)
    {
        if (this-&gt;m_Age == p.m_Age)
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    string m_Name;
    int m_Age;
};</p>
<p>void test02()
{
    vector<Person> v;</p>
<div class="highlight"><pre><span></span><code>Person p1(&quot;刘备&quot;, 35);
Person p2(&quot;关羽&quot;, 35);
Person p3(&quot;张飞&quot;, 35);
Person p4(&quot;赵云&quot;, 30);
Person p5(&quot;曹操&quot;, 25);

v.push_back(p1);
v.push_back(p2);
v.push_back(p3);
v.push_back(p4);
v.push_back(p5);

Person p(&quot;诸葛亮&quot;,35);

int num = count(v.begin(), v.end(), p);
cout &lt;&lt; &quot;num = &quot; &lt;&lt; num &lt;&lt; endl;
</code></pre></div>
<p>}
int main() {</p>
<div class="highlight"><pre><span></span><code>//test01();

test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
<code>`` **总结：** 统计自定义数据类型时候，需要配合重载</code>operator==`</p>
<h4 id="526-count_if-count_ifiterator-beg-iterator-end-_pred">5.2.6 count_if <strong>功能描述：</strong> * 按条件统计元素个数 <strong>函数原型：</strong> - <code>count_if(iterator beg, iterator end, _Pred);</code><a class="headerlink" href="#526-count_if-count_ifiterator-beg-iterator-end-_pred" title="Permanent link">&para;</a></h4>
<p>// 按条件统计元素出现次数</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _Pred 谓词</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_74">include <algorithm><a class="headerlink" href="#include_74" title="Permanent link">&para;</a></h1>
<h1 id="include_75">include <vector><a class="headerlink" href="#include_75" title="Permanent link">&para;</a></h1>
<p>class Greater4
{
public:
    bool operator()(int val)
    {
        return val &gt;= 4;
    }
};</p>
<p>//内置数据类型
void test01()
{
    vector<int> v;
    v.push_back(1);
    v.push_back(2);
    v.push_back(4);
    v.push_back(5);
    v.push_back(3);
    v.push_back(4);
    v.push_back(4);</p>
<div class="highlight"><pre><span></span><code>int num = count_if(v.begin(), v.end(), Greater4());

cout &lt;&lt; &quot;大于4的个数为： &quot; &lt;&lt; num &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>//自定义数据类型
class Person
{
public:
    Person(string name, int age)
    {
        this-&gt;m_Name = name;
        this-&gt;m_Age = age;
    }</p>
<div class="highlight"><pre><span></span><code>string m_Name;
int m_Age;
</code></pre></div>
<p>};</p>
<p>class AgeLess35
{
public:
    bool operator()(const Person &amp;p)
    {
        return p.m_Age &lt; 35;
    }
};
void test02()
{
    vector<Person> v;</p>
<div class="highlight"><pre><span></span><code>Person p1(&quot;刘备&quot;, 35);
Person p2(&quot;关羽&quot;, 35);
Person p3(&quot;张飞&quot;, 35);
Person p4(&quot;赵云&quot;, 30);
Person p5(&quot;曹操&quot;, 25);

v.push_back(p1);
v.push_back(p2);
v.push_back(p3);
v.push_back(p4);
v.push_back(p5);

int num = count_if(v.begin(), v.end(), AgeLess35());
cout &lt;&lt; &quot;小于35岁的个数：&quot; &lt;&lt; num &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>//test01();

test02();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> 按值统计用count，按条件统计用count_if</p>
<h3 id="53-sort">5.3 常用排序算法 <strong>学习目标：</strong> - 掌握常用的排序算法 <strong>算法简介：</strong> - <code>sort</code>             //对容器内元素进行排序<a class="headerlink" href="#53-sort" title="Permanent link">&para;</a></h3>
<ul>
<li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li>
<li><code>merge</code>           // 容器元素合并，并存储到另一容器中</li>
<li><code>reverse</code>       // 反转指定范围的元素</li>
</ul>
<h4 id="531-sort">5.3.1 sort <strong>功能描述：</strong> * 对容器内元素进行排序<a class="headerlink" href="#531-sort" title="Permanent link">&para;</a></h4>
<p><strong>函数原型：</strong> - <code>sort(iterator beg, iterator end, _Pred);</code></p>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>//  beg    开始迭代器</p>
<p>//  end    结束迭代器</p>
<p>// _Pred  谓词</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_76">include <algorithm><a class="headerlink" href="#include_76" title="Permanent link">&para;</a></h1>
<h1 id="include_77">include <vector><a class="headerlink" href="#include_77" title="Permanent link">&para;</a></h1>
<p>void myPrint(int val)
{
    cout &lt;&lt; val &lt;&lt; " ";
}</p>
<p>void test01() {
    vector<int> v;
    v.push_back(10);
    v.push_back(30);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);</p>
<div class="highlight"><pre><span></span><code>//sort默认从小到大排序
sort(v.begin(), v.end());
for_each(v.begin(), v.end(), myPrint);
cout &lt;&lt; endl;

//从大到小排序
sort(v.begin(), v.end(), greater&lt;int&gt;());
for_each(v.begin(), v.end(), myPrint);
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> sort属于开发中最常用的算法之一，需熟练掌握</p>
<h4 id="532-random_shuffle-random_shuffleiterator-beg-iterator-end">5.3.2 random_shuffle <strong>功能描述：</strong> * 洗牌   指定范围内的元素随机调整次序 <strong>函数原型：</strong> - <code>random_shuffle(iterator beg, iterator end);</code><a class="headerlink" href="#532-random_shuffle-random_shuffleiterator-beg-iterator-end" title="Permanent link">&para;</a></h4>
<p>// 指定范围内的元素随机调整次序</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_78">include <algorithm><a class="headerlink" href="#include_78" title="Permanent link">&para;</a></h1>
<h1 id="include_79">include <vector><a class="headerlink" href="#include_79" title="Permanent link">&para;</a></h1>
<h1 id="include_80">include <ctime><a class="headerlink" href="#include_80" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    srand((unsigned int)time(NULL));
    vector<int> v;
    for(int i = 0 ; i &lt; 10;i++)
    {
        v.push_back(i);
    }
    for_each(v.begin(), v.end(), myPrint());
    cout &lt;&lt; endl;</p>
<div class="highlight"><pre><span></span><code>//打乱顺序
random_shuffle(v.begin(), v.end());
for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p>
<h4 id="533-merge-mergeiterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest">5.3.3 merge <strong>功能描述：</strong> * 两个容器元素合并，并存储到另一容器中 <strong>函数原型：</strong> - <code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><a class="headerlink" href="#533-merge-mergeiterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest" title="Permanent link">&para;</a></h4>
<p>// 容器元素合并，并存储到另一容器中</p>
<p>// 注意: 两个容器必须是 <strong>有序的</strong> // beg1   容器1开始迭代器
  // end1   容器1结束迭代器
  // beg2   容器2开始迭代器
  // end2   容器2结束迭代器
  // dest    目标容器开始迭代器</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_81">include <algorithm><a class="headerlink" href="#include_81" title="Permanent link">&para;</a></h1>
<h1 id="include_82">include <vector><a class="headerlink" href="#include_82" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v1;
    vector<int> v2;
    for (int i = 0; i &lt; 10 ; i++) 
    {
        v1.push_back(i);
        v2.push_back(i + 1);
    }</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt; vtarget;
//目标容器需要提前开辟空间
vtarget.resize(v1.size() + v2.size());
//合并  需要两个有序序列
merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());
for_each(vtarget.begin(), vtarget.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> merge合并的两个容器必须的有序序列</p>
<h4 id="534-reverse-reverseiterator-beg-iterator-end">5.3.4 reverse <strong>功能描述：</strong> * 将容器内元素进行反转 <strong>函数原型：</strong> - <code>reverse(iterator beg, iterator end);</code><a class="headerlink" href="#534-reverse-reverseiterator-beg-iterator-end" title="Permanent link">&para;</a></h4>
<p>// 反转指定范围的元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_83">include <algorithm><a class="headerlink" href="#include_83" title="Permanent link">&para;</a></h1>
<h1 id="include_84">include <vector><a class="headerlink" href="#include_84" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v;
    v.push_back(10);
    v.push_back(30);
    v.push_back(50);
    v.push_back(20);
    v.push_back(40);</p>
<div class="highlight"><pre><span></span><code>cout &lt;&lt; &quot;反转前： &quot; &lt;&lt; endl;
for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;

cout &lt;&lt; &quot;反转后： &quot; &lt;&lt; endl;

reverse(v.begin(), v.end());
for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> reverse反转区间内元素，面试题可能涉及到</p>
<h3 id="54-copy">5.4 常用拷贝和替换算法 <strong>学习目标：</strong> - 掌握常用的拷贝和替换算法 <strong>算法简介：</strong> - <code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中<a class="headerlink" href="#54-copy" title="Permanent link">&para;</a></h3>
<ul>
<li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li>
<li><code>replace_if</code>          // 容器内指定范围满足条件的元素替换为新元素</li>
<li><code>swap</code>                     // 互换两个容器的元素</li>
</ul>
<h4 id="541-copy-copyiterator-beg-iterator-end-iterator-dest">5.4.1 copy <strong>功能描述：</strong> * 容器内指定范围的元素拷贝到另一容器中 <strong>函数原型：</strong> - <code>copy(iterator beg, iterator end, iterator dest);</code><a class="headerlink" href="#541-copy-copyiterator-beg-iterator-end-iterator-dest" title="Permanent link">&para;</a></h4>
<p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p>
<p>// beg  开始迭代器</p>
<p>// end  结束迭代器</p>
<p>// dest 目标起始迭代器</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_85">include <algorithm><a class="headerlink" href="#include_85" title="Permanent link">&para;</a></h1>
<h1 id="include_86">include <vector><a class="headerlink" href="#include_86" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v1;
    for (int i = 0; i &lt; 10; i++) {
        v1.push_back(i + 1);
    }
    vector<int> v2;
    v2.resize(v1.size());
    copy(v1.begin(), v1.end(), v2.begin());</p>
<div class="highlight"><pre><span></span><code>for_each(v2.begin(), v2.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> 利用copy算法在拷贝时，目标容器记得提前开辟空间</p>
<h4 id="542-replace-replaceiterator-beg-iterator-end-oldvalue-newvalue">5.4.2 replace <strong>功能描述：</strong> * 将容器内指定范围的旧元素修改为新元素 <strong>函数原型：</strong> - <code>replace(iterator beg, iterator end, oldvalue, newvalue);</code><a class="headerlink" href="#542-replace-replaceiterator-beg-iterator-end-oldvalue-newvalue" title="Permanent link">&para;</a></h4>
<p>// 将区间内旧元素 替换成 新元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// oldvalue 旧元素</p>
<p>// newvalue 新元素</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_87">include <algorithm><a class="headerlink" href="#include_87" title="Permanent link">&para;</a></h1>
<h1 id="include_88">include <vector><a class="headerlink" href="#include_88" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v;
    v.push_back(20);
    v.push_back(30);
    v.push_back(20);
    v.push_back(40);
    v.push_back(50);
    v.push_back(10);
    v.push_back(20);</p>
<div class="highlight"><pre><span></span><code>cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;

//将容器中的20 替换成 2000
cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
replace(v.begin(), v.end(), 20,2000);
for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> replace会替换区间内满足条件的元素</p>
<h4 id="543-replace_if-replace_ifiterator-beg-iterator-end-_pred-newvalue">5.4.3 replace_if <strong>功能描述:</strong> * 将区间内满足条件的元素，替换成指定元素 <strong>函数原型：</strong> - <code>replace_if(iterator beg, iterator end, _pred, newvalue);</code><a class="headerlink" href="#543-replace_if-replace_ifiterator-beg-iterator-end-_pred-newvalue" title="Permanent link">&para;</a></h4>
<p>// 按条件替换元素，满足条件的替换成指定元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// _pred 谓词</p>
<p>// newvalue 替换的新元素</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_89">include <algorithm><a class="headerlink" href="#include_89" title="Permanent link">&para;</a></h1>
<h1 id="include_90">include <vector><a class="headerlink" href="#include_90" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>class ReplaceGreater30
{
public:
    bool operator()(int val)
    {
        return val &gt;= 30;
    }</p>
<p>};</p>
<p>void test01()
{
    vector<int> v;
    v.push_back(20);
    v.push_back(30);
    v.push_back(20);
    v.push_back(40);
    v.push_back(50);
    v.push_back(10);
    v.push_back(20);</p>
<div class="highlight"><pre><span></span><code>cout &lt;&lt; &quot;替换前：&quot; &lt;&lt; endl;
for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;

//将容器中大于等于的30 替换成 3000
cout &lt;&lt; &quot;替换后：&quot; &lt;&lt; endl;
replace_if(v.begin(), v.end(), ReplaceGreater30(), 3000);
for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p>
<h4 id="544-swap-swapcontainer-c1-container-c2">5.4.4 swap <strong>功能描述：</strong> * 互换两个容器的元素 <strong>函数原型：</strong> - <code>swap(container c1, container c2);</code><a class="headerlink" href="#544-swap-swapcontainer-c1-container-c2" title="Permanent link">&para;</a></h4>
<p>// 互换两个容器的元素</p>
<p>// c1容器1</p>
<p>// c2容器2</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_91">include <algorithm><a class="headerlink" href="#include_91" title="Permanent link">&para;</a></h1>
<h1 id="include_92">include <vector><a class="headerlink" href="#include_92" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v1;
    vector<int> v2;
    for (int i = 0; i &lt; 10; i++) {
        v1.push_back(i);
        v2.push_back(i+100);
    }</p>
<div class="highlight"><pre><span></span><code>cout &lt;&lt; &quot;交换前： &quot; &lt;&lt; endl;
for_each(v1.begin(), v1.end(), myPrint());
cout &lt;&lt; endl;
for_each(v2.begin(), v2.end(), myPrint());
cout &lt;&lt; endl;

cout &lt;&lt; &quot;交换后： &quot; &lt;&lt; endl;
swap(v1, v2);
for_each(v1.begin(), v1.end(), myPrint());
cout &lt;&lt; endl;
for_each(v2.begin(), v2.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> swap交换容器时，注意交换的容器要同种类型</p>
<h3 id="55-include-numeric">5.5 常用算术生成算法 <strong>学习目标：</strong> - 掌握常用的算术生成算法 <strong>注意：</strong> * 算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code><a class="headerlink" href="#55-include-numeric" title="Permanent link">&para;</a></h3>
<p><strong>算法简介：</strong> - <code>accumulate</code>      // 计算容器元素累计总和</p>
<ul>
<li><code>fill</code>                 // 向容器中添加元素</li>
</ul>
<h4 id="551-accumulate-accumulateiterator-beg-iterator-end-value">5.5.1 accumulate <strong>功能描述：</strong> *  计算区间内 容器元素累计总和 <strong>函数原型：</strong> - <code>accumulate(iterator beg, iterator end, value);</code><a class="headerlink" href="#551-accumulate-accumulateiterator-beg-iterator-end-value" title="Permanent link">&para;</a></h4>
<p>// 计算容器元素累计总和</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 起始值</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_93">include <numeric><a class="headerlink" href="#include_93" title="Permanent link">&para;</a></h1>
<h1 id="include_94">include <vector><a class="headerlink" href="#include_94" title="Permanent link">&para;</a></h1>
<p>void test01()
{
    vector<int> v;
    for (int i = 0; i &lt;= 100; i++) {
        v.push_back(i);
    }</p>
<div class="highlight"><pre><span></span><code>int total = accumulate(v.begin(), v.end(), 0);

cout &lt;&lt; &quot;total = &quot; &lt;&lt; total &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> accumulate使用时头文件注意是 numeric，这个算法很实用</p>
<h4 id="552-fill-filliterator-beg-iterator-end-value">5.5.2 fill <strong>功能描述：</strong> * 向容器中填充指定的元素 <strong>函数原型：</strong> - <code>fill(iterator beg, iterator end, value);</code><a class="headerlink" href="#552-fill-filliterator-beg-iterator-end-value" title="Permanent link">&para;</a></h4>
<p>// 向容器中填充元素</p>
<p>// beg 开始迭代器</p>
<p>// end 结束迭代器</p>
<p>// value 填充的值</p>
<p><strong>示例：</strong> ```c++</p>
<h1 id="include_95">include <numeric><a class="headerlink" href="#include_95" title="Permanent link">&para;</a></h1>
<h1 id="include_96">include <vector><a class="headerlink" href="#include_96" title="Permanent link">&para;</a></h1>
<h1 id="include_97">include <algorithm><a class="headerlink" href="#include_97" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt; v;
v.resize(10);
//填充
fill(v.begin(), v.end(), 100);

for_each(v.begin(), v.end(), myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> 利用fill可以将容器区间内元素填充为 指定的值</p>
<h3 id="56-">5.6 常用集合算法 <strong>学习目标：</strong> - 掌握常用的集合算法<a class="headerlink" href="#56-" title="Permanent link">&para;</a></h3>
<p><strong>算法简介：</strong> - <code>set_intersection</code>          // 求两个容器的交集</p>
<ul>
<li>
<p><code>set_union</code>                       // 求两个容器的并集</p>
</li>
<li>
<p><code>set_difference</code>              // 求两个容器的差集</p>
</li>
</ul>
<h4 id="561-set_intersection-set_intersectioniterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest">5.6.1 set_intersection <strong>功能描述：</strong> * 求两个容器的交集 <strong>函数原型：</strong> - <code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><a class="headerlink" href="#561-set_intersection-set_intersectioniterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest" title="Permanent link">&para;</a></h4>
<p>// 求两个集合的交集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong> // beg1 容器1开始迭代器
  // end1 容器1结束迭代器
  // beg2 容器2开始迭代器
  // end2 容器2结束迭代器
  // dest 目标容器开始迭代器</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_98">include <vector><a class="headerlink" href="#include_98" title="Permanent link">&para;</a></h1>
<h1 id="include_99">include <algorithm><a class="headerlink" href="#include_99" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v1;
    vector<int> v2;
    for (int i = 0; i &lt; 10; i++)
    {
        v1.push_back(i);
        v2.push_back(i+5);
    }</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt; vTarget;
//取两个里面较小的值给目标容器开辟空间
vTarget.resize(min(v1.size(), v2.size()));

//返回目标容器的最后一个元素的迭代器地址
vector&lt;int&gt;::iterator itEnd = 
    set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

for_each(vTarget.begin(), itEnd, myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> </p>
<ul>
<li>求交集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从 <strong>两个容器中取小值</strong> * set_intersection返回值既是交集中最后一个元素的位置</li>
</ul>
<h4 id="562-set_union-set_unioniterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest">5.6.2 set_union <strong>功能描述：</strong> * 求两个集合的并集 <strong>函数原型：</strong> - <code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><a class="headerlink" href="#562-set_union-set_unioniterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest" title="Permanent link">&para;</a></h4>
<p>// 求两个集合的并集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong> // beg1 容器1开始迭代器
  // end1 容器1结束迭代器
  // beg2 容器2开始迭代器
  // end2 容器2结束迭代器
  // dest 目标容器开始迭代器</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_100">include <vector><a class="headerlink" href="#include_100" title="Permanent link">&para;</a></h1>
<h1 id="include_101">include <algorithm><a class="headerlink" href="#include_101" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v1;
    vector<int> v2;
    for (int i = 0; i &lt; 10; i++) {
        v1.push_back(i);
        v2.push_back(i+5);
    }</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt; vTarget;
//取两个容器的和给目标容器开辟空间
vTarget.resize(v1.size() + v2.size());

//返回目标容器的最后一个元素的迭代器地址
vector&lt;int&gt;::iterator itEnd = 
    set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());

for_each(vTarget.begin(), itEnd, myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> </p>
<ul>
<li>求并集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要 <strong>两个容器相加</strong> - set_union返回值既是并集中最后一个元素的位置</li>
</ul>
<h4 id="563-set_difference-set_differenceiterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest">5.6.3  set_difference <strong>功能描述：</strong> * 求两个集合的差集 <strong>函数原型：</strong> - <code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);</code><a class="headerlink" href="#563-set_difference-set_differenceiterator-beg1-iterator-end1-iterator-beg2-iterator-end2-iterator-dest" title="Permanent link">&para;</a></h4>
<p>// 求两个集合的差集</p>
<p>// <strong>注意:两个集合必须是有序序列</strong> // beg1 容器1开始迭代器
  // end1 容器1结束迭代器
  // beg2 容器2开始迭代器
  // end2 容器2结束迭代器
  // dest 目标容器开始迭代器</p>
<p><strong>示例：</strong> ```C++</p>
<h1 id="include_102">include <vector><a class="headerlink" href="#include_102" title="Permanent link">&para;</a></h1>
<h1 id="include_103">include <algorithm><a class="headerlink" href="#include_103" title="Permanent link">&para;</a></h1>
<p>class myPrint
{
public:
    void operator()(int val)
    {
        cout &lt;&lt; val &lt;&lt; " ";
    }
};</p>
<p>void test01()
{
    vector<int> v1;
    vector<int> v2;
    for (int i = 0; i &lt; 10; i++) {
        v1.push_back(i);
        v2.push_back(i+5);
    }</p>
<div class="highlight"><pre><span></span><code>vector&lt;int&gt; vTarget;
//取两个里面较大的值给目标容器开辟空间
vTarget.resize( max(v1.size() , v2.size()));

//返回目标容器的最后一个元素的迭代器地址
cout &lt;&lt; &quot;v1与v2的差集为： &quot; &lt;&lt; endl;
vector&lt;int&gt;::iterator itEnd = 
    set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());
for_each(vTarget.begin(), itEnd, myPrint());
cout &lt;&lt; endl;


cout &lt;&lt; &quot;v2与v1的差集为： &quot; &lt;&lt; endl;
itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());
for_each(vTarget.begin(), itEnd, myPrint());
cout &lt;&lt; endl;
</code></pre></div>
<p>}</p>
<p>int main() {</p>
<div class="highlight"><pre><span></span><code>test01();

system(&quot;pause&quot;);

return 0;
</code></pre></div>
<p>}
``` <strong>总结：</strong> </p>
<ul>
<li>求差集的两个集合必须的有序序列</li>
<li>目标容器开辟空间需要从 <strong>两个容器取较大值</strong> - set_difference返回值既是差集中最后一个元素的位置</li>
</ul>





                
              </article>
            </div>
          
          
  <script>var tabs=__md_get("__tabs");if(Array.isArray(tabs))e:for(var set of document.querySelectorAll(".tabbed-set")){var tab,labels=set.querySelector(".tabbed-labels");for(tab of tabs)for(var label of labels.getElementsByTagName("label"))if(label.innerText.trim()===tab){var input=document.getElementById(label.htmlFor);input.checked=!0;continue e}}</script>

        </div>
        
          <button type="button" class="md-top md-icon" data-md-component="top" hidden>
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M13 20h-2V8l-5.5 5.5-1.42-1.42L12 4.16l7.92 7.92-1.42 1.42L13 8v12Z"/></svg>
            回到页面顶部
          </button>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../../..", "features": ["content.action.edit", "content.code.annotate", "content.code.copy", "content.tabs.link", "content.tooltips", "navigation.indexes", "navigation.sections", "navigation.tabs", "navigation.top", "navigation.tracking", "search.highlight", "search.suggest", "toc.follow"], "search": "../../../assets/javascripts/workers/search.74e28a9f.min.js", "translations": {"clipboard.copied": "\u5df2\u590d\u5236", "clipboard.copy": "\u590d\u5236", "search.result.more.one": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.more.other": "\u5728\u8be5\u9875\u4e0a\u8fd8\u6709 # \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.none": "\u6ca1\u6709\u627e\u5230\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.one": "\u627e\u5230 1 \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.other": "# \u4e2a\u7b26\u5408\u6761\u4ef6\u7684\u7ed3\u679c", "search.result.placeholder": "\u952e\u5165\u4ee5\u5f00\u59cb\u641c\u7d22", "search.result.term.missing": "\u7f3a\u5c11", "select.version": "\u9009\u62e9\u5f53\u524d\u7248\u672c"}}</script>
    
    
      <script src="../../../assets/javascripts/bundle.220ee61c.min.js"></script>
      
        
          <script src="../../../mathjax.js"></script>
        
      
        
          <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        
      
        
          <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
      
    
  </body>
</html>