### 可微渲染器代码实现

#### 可能的问题

- 如果严格按照前文推导的公式进行梯度的计算，可能会出现梯度计算结果非常大的情况。
  - 这是因为，一方面，初始状态下与优化目标的距离较大，导致梯度值较大；另一方面，单个体素的梯度可能包含许多条光线的贡献。因此，需要通过调整学习率来调节优化，也可以对梯度进行映射或截断，比如对超过 $[-1, 1]$ 的梯度进行截断，以保证较为稳定的学习。
- 值得注意的是，taichi 内置的 `taichi.tools.imread()` 与 `taichi.tools.imwrite()` 函数是按照 `w,h,c` 的顺序存储的，与 cv2 和 plt （`h,w,c`） 都不同，转换关系为 `image(in taichi) = image.permute(1,0,2).flip(0)` 。  